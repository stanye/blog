[{"title":"同步git本地分支和远程分支","date":"2019-07-29T02:28:32.000Z","path":"2019/07/29/sync-git-local-branch-with-remote-branch.html","text":"git branch的时候看到一大堆分支，感觉想全部干掉. 查看分支 123456// allgit branch -a// localgit branch// remotegit branch -r 查看本地分支和追踪情况 1git remote show origin 出现stale (use &#39;git remote prune&#39; to remove) 删除远程上的 1git remote prune origin 删除本地的 12// 正常操作 强制删除用-Dgit branch -d lalala","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"git","slug":"git","permalink":"https://stanye.com/blog/tags/git/"},{"name":"git branch","slug":"git-branch","permalink":"https://stanye.com/blog/tags/git-branch/"}]},{"title":"mac更新系统引发apache403问题","date":"2019-07-19T07:18:32.000Z","path":"2019/07/19/how-to-fix-apache-403.html","text":"今天无意中发现apache服务启动不起来，一直报403的错误。 apache 403百度几个方案，都无法解决，最终在Mac OS下开启自带的apache服务文章里，解决： 因为Mac版本升级导致了apache策略发生变更了，所以我们修改后还是会出现403无权访问的情况。解决方法:备份原有的httpd.conf配置文件,把同级目录下的httpd.conf.pre-update 重命名为httpd.conf其他配置照搬之前的（网站文档目录及端口ServerName的配置） 重启遇到的两个问题AH00557: httpd: apr_sockaddr_info_get() failed for…AH00558: httpd: Could not reliably determine…When restart the httpd. Try: 1sudo /usr/sbin/apachectl restart Don’t use: 1sudo apachectl restart 为什么会出现类似的问题呢因为你电脑装了两个不同版本的Apache 如果还有问题?修改/etc/apache2/httpd.conf将#ServerName www.example.com:80的注释去掉可以换成自己定义的域名","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"apache","slug":"apache","permalink":"https://stanye.com/blog/tags/apache/"},{"name":"MacOS","slug":"MacOS","permalink":"https://stanye.com/blog/tags/MacOS/"},{"name":"Mojave","slug":"Mojave","permalink":"https://stanye.com/blog/tags/Mojave/"}]},{"title":"E3游戏WishList2019","date":"2019-06-18T05:03:25.000Z","path":"2019/06/18/e3-game-wishList-2019.html","text":"有生之年系列, 居然到了一年一度的E3去年的文章 2018年E3的wishlist到今天的总结 Battlefield V 没入 Anthem 暴死 Assassin’s Creed Odyssey 试玩可以 The Division 2 比1好玩，但制作组作死，削的人退坑 Sekiro：Shadows Die Twice 犹豫就败北 好玩 Fall out 76 暴死 Devil May Cry 5 好玩 Shadow of the Tomb Raider 这个热度不大，没入 Cyberpunk 2077, The Elder Scrolls VI, Beyond Good and Evil 还没出 Resident Evil 2 : RE 云通关 Death Stranding 它就还在摸鱼 Total War: Three Kingdoms 好玩 2019的E3总结game Name Release Postscript Cyberpunk 2077 PC 100 The Elder Scrolls VI PC 100 Beyond Good and Evil 2 PC 100 Death Stranding PS4? 100 The Legend of Zelda：Breath of the wild NS 100 Elden Ring PC 90 WatchDogs: Legion PC 90 FF7:RM PC 90 HardWareXbox Scarlett to be continued…","categories":[{"name":"Game","slug":"Game","permalink":"https://stanye.com/blog/categories/Game/"}],"tags":[{"name":"E3","slug":"E3","permalink":"https://stanye.com/blog/tags/E3/"}]},{"title":"如何开发油猴脚本来block掘金用户","date":"2019-05-14T15:32:51.000Z","path":"2019/05/14/how-to-develop-tampermonkey.html","text":"随着掘金用户不断增加，或多或少遇到”钢筋”用户。秉着眼不见为净的原则，在官方没有出屏蔽功能的情况下，利用油猴实现block用户。 使用 浏览器安装Tampermonkey扩展 访问脚本网站greasyfork.org安装本扩展 点击页面上脚本扩展的block按钮 https://github.com/stanye/UserScripts 欢迎提issue和PR 实现方法 根据用户id用jQueryremove相关DOM1$(`.username[href=\"/user/$&#123;id&#125;\"]`).parents('.item').remove(); Tampermonkey中使用jQuery1// @require https://code.jquery.com/jquery-3.3.1.min.js 只针对掘金站点1// @include /^https?:\\/\\/(\\w+\\.)?juejin\\.im\\// 用户id 以我的为例 https://juejin.im/user/58f56b4b0ce463006bc084eb58f56b4b0ce463006bc084eb就是id 存储和读取blockList使用localStorage操作, 不做赘述 在页面中加按钮 dropdown-menu action-box 1234const actionBox = $('.user-info-block .action-box');if (actionBox.has('.big-block-btn').length === 0) &#123; actionBox.append(`&lt;button $&#123;scope&#125; class=\"follow-btn btn big-block-btn\" style=\"color: red;\"&gt;Block&lt;/button&gt;`);&#125; scope样式问题掘金用了vue的scope，用jQuery新增的内容想要套用原来的样式需要获取到scope生成的hash 1const scope = $('.user-info-block .action-box')[0].attributes.item(0).nodeName; 给按钮增加点击事件1$('#juejin').on('click', '.block-btn', block); jQuery获取dom早于vue请求数据并渲染123456// 分页$(window).on('scroll', () =&gt; &#123; startClear();&#125;);// 第一次setTimeout(startClear, 1000); 暂时没好想法,先setTimeout和scroll 发布利用github的Webhooks同步发布到greasyfork 初始化import脚本 初始化import脚本 开启webhook并应用 开启webhook并应用 按提示在github仓库的settings -&gt; webhooks创建hook, 每次仓库更新就会同步更新到greasyfork 小结 本意只是脑子一闪而过的idea，并付诸实现。 良好的社区气氛还是需要大家共同努力的。 TODO 覆盖掘金全站的block脚本 针对某条回复的block blockList管理 代码不够优雅，需要去掉硬编码","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"tampermonkey","slug":"tampermonkey","permalink":"https://stanye.com/blog/tags/tampermonkey/"},{"name":"jQuery","slug":"jQuery","permalink":"https://stanye.com/blog/tags/jQuery/"},{"name":"juejin.im","slug":"juejin-im","permalink":"https://stanye.com/blog/tags/juejin-im/"}]},{"title":"记录博客切换成gitalk的Error/no Issues问题","date":"2019-05-13T10:05:38.000Z","path":"2019/05/13/switch-to-gitalk.html","text":"常见问题不做累述，记录几个配置心得 太长不看版 我的主域名是stanye.com, 我的博客域名是stanye.com/blog/, 虽然是给博客申请gitalk, 但是OAuth申请的时候填的的都是https://stanye.com/(对应没域名的stanye.github.io) 前言我的博客当前配置: 使用hexo搭建博客 使用的主题是hexo-theme-indigo 使用的valine评论, 想要切换到gitalk 使用了github pages / 使用了自己的域名 / blog仓库不是github pages主仓库 关于gitalkGitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。使用 Github 帐号登录，界面干净整洁，最喜欢的一点是支持 MarkDown语法 主要特性： 使用 Github 登录 支持多语言 [en, zh-CN, zh-TW, es-ES, fr] 支持个人或组织 无干扰模式（设置 distractionFreeMode 为 true 开启） 快捷键提交评论 （cmd|ctrl + enter） 支持MarkDown语法 创建OAuth Application用github账号创建了一个账号应用, 用户授权登录gitalk, 点击申请 以我的域名stanye.com为例 图片 我的主域名是stanye.com, 我的博客域名是stanye.com/blog/, 虽然是给博客申请gitalk, 但是这地方填写的都是https://stanye.com/ 配置因为indigo已经支持gitalk(不支持请更新到最新代码), 需要配置_config.yml 以我的githubgithub.com/stanye/blog为例 12345678gitalk: // github用户名 owner: stanye // 仓库名 repo: blog // 上一步OAuth Application生成的 client_id: b7ecea36c7957fdadfb6 client_secret: 95dddf9298936c42c983f727c2f40c118d30a147","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"gitalk","slug":"gitalk","permalink":"https://stanye.com/blog/tags/gitalk/"},{"name":"hexo-indigo-theme","slug":"hexo-indigo-theme","permalink":"https://stanye.com/blog/tags/hexo-indigo-theme/"},{"name":"hexo","slug":"hexo","permalink":"https://stanye.com/blog/tags/hexo/"}]},{"title":"aliyun-centos-fix","date":"2019-04-26T08:22:09.000Z","path":"2019/04/26/aliyun-centos-fix.html","text":"这几天体验了下安骑士, 发现裸奔有些警告, 做了一些修复. 禁止root直接登录 创建一个账号www 修改/etc/ssh/sshd_config, PermitRootLogin改成no 默认登录端口检测修改/etc/ssh/sshd_config, 去掉Port 22注释#，并修改22为其它值 设置用户密码 修改/etc/security/pwquality.conf 去掉minlen注释，设置最小密码长度10 去掉dcredit注释，设置数字位数为负数建议-1(最少包含1位数字) 去掉ucredit注释，设置大写字母位数为负数-1(最少包含1位大写字母) 去掉lcredit注释，设置小写字母位数为负数-1(最少包含1位小写字母) 去掉ocredit注释，设置特殊字符位数为负数-1(最少包含1位特殊字符) 密码时间 修改/etc/login.defs 密码失效时间, 365天 最小间隔时间, 7天","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"centOS","slug":"centOS","permalink":"https://stanye.com/blog/tags/centOS/"},{"name":"aliyun","slug":"aliyun","permalink":"https://stanye.com/blog/tags/aliyun/"}]},{"title":"使用git rebase对commits进行（合并/拆分/修改作者信息）","date":"2019-04-04T09:55:32.000Z","path":"2019/04/04/use-git-rebase-to-combine-split-resign-your-commits.html","text":"这几天做开源项目，项目负责人对commits要求很高，故总结了合并/拆分commits以及修改提交信息等相关. 1. 对多个commits合并 首先查看历史信息 1git log --oneline 想合并前两条 123git rebase -i Head~2// 或者git rebase -i 33bda27 // 前一条 将第二条的pick改成squash 保存, 修改提交信息, 再保存，查看git log --oneline, 确认修改完成 使用git push提交（视情况加-fforce） 2. 对单个commits拆分 以合并的结果做拆分演示 想拆分第一条 123git rebase -i Head~1// 或者git rebase -i 33bda27 // 前一条 将第一条的pick改成edit, 后保存并退出 发现此时属于rebase阶段 1git reset HEAD^ // 拉取之后的提交到版本库的文件到暂存区, 改操作不影响工作区 使用git add和git commit分文件进行提交, 生成不同的commits 提交完成后使用git rebase --continue, 完成rebase. 使用git push提交（视情况加-fforce） 3. 更改作者信息上述rebase步骤中加入1git commit --amend --author &quot;aaa &lt;bbb@cc.com&gt;&quot; // 要修改的作者名字和邮箱 4. 如何rebase第一条（root）上述rebase起始步骤中加入1git rebase -i --root// 要修改的作者名字和邮箱 PS：如果想修改root的提交信息呢1234567git checkout &lt;sha1-of-root&gt; // checkout到第一条git commit --amend --author &quot;aaa &lt;bbb@cc.com&gt;&quot; // 要修改的作者名字和邮箱// ORgit commit --amend --reset-authorgit rebase --onto HEAD HEAD master 5. one more thinggit commit加-s参数可以加上Signed-off-by信息","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"git","slug":"git","permalink":"https://stanye.com/blog/tags/git/"},{"name":"git rebase","slug":"git-rebase","permalink":"https://stanye.com/blog/tags/git-rebase/"}]},{"title":"学习TS的一些知识点总结2","date":"2018-11-23T08:56:26.000Z","path":"2018/11/23/some-basic-knowledge-while-learning-typescript.html","text":"接上一篇，学习TS对JS的一些概念的补充，ES6一些设计的趋向于Java和PHP，有一定的亲和力 类Class 定义事物抽象特点，包含属性和方法 constructor 构造函数, new 的时候自动调用 extends 继承 super 调用父类的构造函数和方法 实例属性ES7支持在 constructor 外也可以定义 对象Object面向对象OOP(Object Oriented Programming)封装Encapsulation继承Inheritance多态Polymorphism存取器(getter &amp; setter)1234567891011121314151617class Mobile &#123; constructor(mobile) &#123; this.mobile = mobile; &#125; get mobile() &#123; return 'iPhone6s'; &#125; set mobile(name) &#123; console.log('setter: ' + name); &#125;&#125;let a = new Mobile('P10'); // setter: P10a.mobile = 'P10 pro'; // setter: P10 proconsole.log(a.mobile); // iPhone6s 想起了之前学vue中双向绑定的原理是什么(靠Object.defineProperty() get set方法) 修饰符(Modifiers) static 修饰静态变量(ES7)和方法(ES6) TS 访问修饰符(Access Modifiers): public 、protected 、 private 抽象类(Abstract Class) 抽象类不允许被实例化 抽象方法必须在子类实现 接口(Interfaces) 描述对象的形象(Sharp) 提取公共实现(implements) 接口可以继承接口 1234567interface Company &#123; alert();&#125;interface System extends Company &#123; isOpenSource();&#125; 接口可以继承类 12345678interface Size &#123; x: number; y: number;&#125;interface System extends Size &#123; os: string&#125; 实现(implements) 公共特性提取成接口（interfaces），用 implements 关键字来实现 一个类可以有多个implements 1class Mobile implements System, Price, Company &#123;&#125;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://stanye.com/blog/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://stanye.com/blog/tags/typescript/"}]},{"title":"学习TS的一些知识点总结","date":"2018-11-12T06:14:26.000Z","path":"2018/11/12/ts-basics.html","text":"学习TS中, 才发现js基础太差了, 学习整理ing(持续更新…) 数据类型原始数据类型(Primitive data types) Number ES6 可以用二进制表示法前缀0b（或0B）例如0b1010 ES6 可以用八进制表示法0o（或0O）例如0o744 用Number方法转十进制 String Boolean boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数 Null Undefined 与 void 的区别是，undefined 和 null 是所有类型的子类型。 Symbol (ES6新增) MDN文档 空值(Void) TS中才有 TS中用void表示没有任何返回值的函数 123function test(): void &#123; console.log('no return');&#125; 对象类型(Object types)函数声明(函数声明和函数表达式)Function Declaration123456789function test(a: string, b: string): string &#123; return `$&#123;a&#125; is $&#123;b&#125;`&#125;// 上面用解构的写法如下:function test(&#123; a = 'default', b &#125;: &#123; a: string; b: string; &#125;): string &#123; return `$&#123;a&#125; is $&#123;b&#125;`&#125; Function Expression123var test: (a: string, b: string) =&gt; string = function (a: string, b: string): string &#123; return `$&#123;a&#125; is $&#123;b&#125;`&#125; ES6箭头函数和TS的箭头函数会混淆 接口的方式声明12345678interface StringConcatFunc &#123; (a: string, b: string): string&#125;let test: StringConcatFunc; test = function (a: string, b: string): string &#123; return `$&#123;a&#125; is $&#123;b&#125;`; &#125; 可选参数必须放在必选参数后面 a: string, b?: string 或者设置默认值和ES6类似 b?: string = &#39;default&#39;, a: string 此时会报错Parameter cannot have question mark and initializer. 需要修改成b: string = &#39;default&#39;, a: string 支持重载，先精确定义方法，再在最后写实现 导入/导出export 整体导出 1module.exports = aaa; 单个导出 1exports.aaa = aaa; import 整体导入 1import * as aaa from 'aaa'; 官方推荐1234// importimport aaa = require('aaa');// exportexport = aaa; 任意值(Any) 允许赋值为任意类型 未指定其类型会被识别为任意值类型 类型推论(Type Inference)联合类型（Union Types)1let a: number | string; 只能访问所有类型里共有的属性或方法 Interfaces接口, 对行为的抽象, 用classes定义implements(实现) 对类的行为进行抽象 对对象的形状进行描述 123456789interface Mobile &#123; name: string, system: string&#125;let myPhone: Mobile = &#123; name: 'iphone6s', system: 'iOS11.2'&#125; 有点像写react的propType, 变量的形状和接口的形状一定要一致 可选属性 12345678interface Mobile &#123; name: string, system?: string&#125;let myPhone: Mobile = &#123; name: 'iphone6s'&#125; 不报错 任意属性 12345678910interface Mobile &#123; name: string, system?: string, [propName: string]: any&#125;let myPhone: Mobile = &#123; name: 'iphone6s', price: 5388&#125; 只读readonly 12345678910111213interface Mobile &#123; readonly company: string, name: string, system?: string, [propName: string]: any&#125;let myPhone: Mobile = &#123; name: 'iphone6s', price: 5388, company: 'apple'&#125;myPhone.company = 'nokia'; // error 数组类型 type + 方括号 1let arr: string[] = ['1', '2', '3'] 泛型 (Array Generic) 1let arr: Array&lt;string&gt; = ['1', '2', '3'] 接口 12345interface StringArray &#123; [index: number]: string&#125;let arr: StringArray = ['1', '2', '3']; any[] 表示任意数组 类数组 Array-like Object 123function test() &#123; let args: IArguments = arguments;&#125; IArguments就是内置数组 元组Tuple(吐槽记成了元祖, 元祖高达) 与数组类似, 数组内有相同元素, 元组有不同类型 1let test: [string, number] = ['1', 2]; 类型断言Type Assertion &lt;类型&gt;值 123function test (a: string | number) &#123; console.log((&lt;string&gt;a).length);&#125; 值 as 类型 react必须用值 as 类型 泛型Generics 定义函数、接口、类的时候不指定类型，使用的时候再指定 123456789101112function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;function test&lt;T, U&gt;(a: [T, U]): [U, T] &#123; return [a[1], a[0]];&#125;​ `&lt;T&gt;`任意类型 泛型约束 12345678interface LengthWise &#123; length: number&#125;function countArray&lt;T extends LengthWise&gt;(args: T): T &#123; console.log('argsLength: ', args.length); return args;&#125; 泛型接口内置对象 ES标准 Boolean Error Date Regexp global object typescript实现 DOM和BOM Document HTMLElement Event NodeList typescript实现 声明声明文件 放一个单独的文件example.d.ts 声明的使用方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 声明全局变量declare var a: (b: string) =&gt; any;declare const b;declare let c;// 声明全局方法 支持重载declare function test (): any &#123;&#125;// 声明全局类declare class Mobile &#123; name: string; constructor(name: string);&#125;let myPhone = new Mobile('iPhone6s');// 声明全局枚举declare enum Systems &#123; iOS, Android, WindowsPhone, Symbian&#125;console.log(Systems[\"iOS\"] === 0); // trueconsole.log(Systems[0] === \"iOS\"); // true// 声明全局对象 被ES6淘汰declare namespace Example &#123; function test...&#125;// 声明全局类型interface test &#123;&#125;// 声明全局类型type System = string;type SystemVersion = () =&gt; string; // `类型别名`常用于联合类型 type SystemOrVersion = System | SystemVersion; function getSystem(n: SystemOrVersion): System &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125; &#125; // 声明`字符串字面量`类型 type EventNames = 'click' | 'touch' | 'scroll'; function handleEvent(ele: Element, event: EventNames) &#123; // do something &#125;// 扩展全局变量declare global &#123; interface String &#123; sayYes(): string &#125;&#125;// 扩展模块 先import再declareimport * as aaa from 'aaa';declare module 'aaa' &#123; export function lalala(): aaa.toArray();&#125; 第三方声明文件, 发布到@types 用@types下载 http://microsoft.github.io/TypeSearch/ 1npm i @types/react --save package.json中types字段或者index.d.ts 创建types目录, tsconfig.json 中的 paths 和 baseUrl 字段。 12345678910&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"baseUrl\": \"./\", \"paths\": &#123; \"*\": [\"types/*\"] &#125; &#125;&#125;` 声明合并 函数合并(重载) 接口合并 overload 重载(方法名一样，参数不一样) js不支持重载 可以自己根据参数进行条件判断进行重载 闭包实现重载 参考https://www.cnblogs.com/yugege/p/5539020.html ES6带来了Proxy和Reflect可以实现重载 overwrite 重写override 覆盖参考文档 https://www.tslang.cn/docs/home.html https://ts.xcatliu.com","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://stanye.com/blog/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://stanye.com/blog/tags/typescript/"}]},{"title":"升级macOS Mojave后问题汇总及解决办法","date":"2018-10-23T06:11:26.000Z","path":"2018/10/23/macOS-Mojave-problems-and-solutions.html","text":"搜狗问题描述：系统升级之后发现断断续续一直鼠标在转圈 解决方案：搜狗升级到`4.8`之后解决问题 zsh问题描述：升级后使用iTerm出现乱码，原生terminal没问题 解决方案：iTerms2 -&gt; Preferences -&gt; Advanced -&gt; 搜索LC_CTYPE -&gt; value值设置`zh_CN.UTF-8` VSCode问题描述：字体变细 解决方案：命令行输入`defaults write -g CGFontRenderingFontSmoothingDisabled -bool NO` Wechat和Tim问题描述：输入框焦点容易丢失，必须手动点击程序 解决方案：升级最新版Wechat和Tim Git丢失问题描述：更新后git没了 解决方案：命令行输入`xcode-select –install` Hexo问题描述：写这篇文字的时候，居然发现生成的页面英文的地方被转成日文 解决方案：_config.yml文件language设置`zh-Hans`","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://stanye.com/blog/tags/MacOS/"},{"name":"Mojave","slug":"Mojave","permalink":"https://stanye.com/blog/tags/Mojave/"}]},{"title":"E3游戏WishList2018","date":"2018-06-11T04:26:25.000Z","path":"2018/06/11/E3游戏WishList.html","text":"E3游戏整理 Name Game Platform Expectation Value Price Release Postscript Battlefield V PC 90 384 - Origin平台 Command&amp;Conquer:Rivals Mobile 60 - - - Anthem PC 80 - 2019/2/22 命运2like Kingdom Hearts 3 PS4 70 - 2019/1/25 NO PC Assassin’s Creed Odyssey PC 80 - - this is sparta The Division 2 PC 90 - 2019/3/15 原力2 Halo Infinite XBOX 90 - - 玩不到 Sekiro：Shadows Die Twice PC 90 - - 受虐狂 Fall out 76 PC 70 - - Online Devil May Cry 5 PC 90 - - 恶魔五月哭 Shadow of the Tomb Raider PC 90 ￥379 2018/9/15 劳拉 Cyberpunk 2077 PC 90 - - - Doom Eternal PC 70 - - - The Elder Scrolls VI PC 100 - - - Starfiled PC 60 - - - Beyond Good and Evil 2 PC 80 - - - Resident Evil 2 : RE PC 80 - - - Death Stranding PC 100 - - -","categories":[{"name":"Game","slug":"Game","permalink":"https://stanye.com/blog/categories/Game/"}],"tags":[{"name":"E3","slug":"E3","permalink":"https://stanye.com/blog/tags/E3/"}]},{"title":"leetcode - 350. 两个数组的交集 II","date":"2018-06-06T03:41:43.000Z","path":"2018/06/06/leetcode-350-两个数组的交集-II.html","text":"给定两个数组，写一个方法来计算它们的交集。例如: 给定 nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2]. 注意： - 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 - 我们可以不考虑输出结果的顺序。 跟进: - 如果给定的数组已经排好序呢？你将如何优化你的算法？ - 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ - 如果nums2的元素存储在磁盘上，内存是有限的，你不能一次加载所有的元素到内存中，你该怎么办？ 我的答案： 12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; var arr = []; var List = []; for (var i = 0; i &lt; nums1.length; i++) &#123; List.push(nums1[i]); &#125; for (var i = 0; i &lt; nums2.length; i++) &#123; var cNum = nums2[i]; var cIndex = List.indexOf(cNum); if (cIndex != -1) &#123; delete List[cIndex]; arr.push(cNum); &#125; &#125; return arr;&#125;; 给出的耗时最短解 1234567891011121314151617181920/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; const map=&#123;&#125;; const res=[]; nums1.forEach(function (v) &#123; map[v]?map[v]++:map[v]=1; &#125;); nums2.forEach(function (v) &#123; if(map[v])&#123; res.push(v); map[v]--; &#125; &#125;); return res;&#125;;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://stanye.com/blog/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://stanye.com/blog/tags/algorithm/"}]},{"title":"Skeleton Screen - 骨架屏设计","date":"2018-05-30T03:00:00.000Z","path":"2018/05/30/skeleton-screen.html","text":"Skeleton Screen 陈纬杰 - 使用 Skeleton Screen 提升用户感知体验 https://cloud.tencent.com/developer/article/1006169 龙爪槐守望者 - 这个控件叫：Skeleton Screen/加载占位图 https://www.jianshu.com/p/d152e1d84296","categories":[{"name":"产品设计","slug":"产品设计","permalink":"https://stanye.com/blog/categories/产品设计/"}],"tags":[{"name":"skeleton screen","slug":"skeleton-screen","permalink":"https://stanye.com/blog/tags/skeleton-screen/"}]},{"title":"技术型产品经理需要了解的知识点","date":"2018-05-10T11:11:22.000Z","path":"2018/05/10/Technical-product-manager.html","text":"MVCMVC是一个框架模式，它强制性的使应用程序的输入、处理和输出分开。以JAVA为例，最典型的MVC就是JSP + SERVLET+ JAVABEAN的模式。通俗的讲，程序可以有一种方式的写法，都在JSP的代码中处理所有事情。但是这样回答来极大的耦合问题，所以才去MVC模式把视觉（前台）、后台、数据库拆分开来处理。减少偶尔、增加复用性等。 URL 路由 模板 一段代码经常被重复使用，我们的工程师们会把它封装成一个文件，然后在需要使用的时候去调用它。我们在设计产品的时候其实常用到这个思维，比如设计权限模块，你需要做的是把一个系统中的公司、分公司、部门等进行拆分，封装成不同的功能。 RESTful API http://www.ruanyifeng.com/blog/2014/05/restful_api MySQL Bootstrap Redis, 用Memcached或Redis来做缓存，提高应用性能 版本管理Git、svn Markdown 前后端分离 微信H5开发 Docker 机器学习 Chrome 调试你能够感知到的一般都是你所能看到的，这些BUG都是很简单就能修复的。 CURL 测试 API 数据分析埋点 学前端不要写脚本抢月饼，学后端记得做好权限检查 http的基本原理 app和h5的区别以及通信。 web前端的基本概念。 后台的基本知识 常用的技术术语，比如SDK，插件，接口，协议等等 数据库的基础知识一方面，有助于与技术的沟通及产品的实现；另一方面，特别是在创业型公司，查询后台不完善甚至压根没有，很多时候需要出数据（如了解交易量、转化率等），如果自己不会的话就得麻烦开发大哥了。但是，都很忙的。一次两次还好，次数多了早晚要被嫌弃。有人说提需求开发数据平台，在人力紧张需求优先级低的情况下谁给你开发？select…from…where…group by….order by.. 前端和后端的关系 HTTP与HTTPs的区别 比如get和post 比如算法到底是个啥意思 比如接口是个啥意思（天天说对接，对接什么玩意） XML和Json都是什么 html5里有什么值得利用的新特性 他们按f12调出来的是什么、可以干什么研发资源非常珍贵。 base64编码能帮你们做到什么 数据库的一些基本概念 域名、URL、IP到底都是什么。 主要是网站产品主要依靠浏览器编程语言开发的php,java或者Python。产品项目中使用开发框架，是团队自己研发的框架，还是使用市面上比较流行的框架。其次是数据库的选择，根据你们的业务需求是使用mysql这种关系型数据库还是mongodb这类非关系型数据库最后就是服务器，服务器一般关心的问题就是稳定性，安全性，还有负载了根据不同需求选择服务器，使用什么样的服务器？自己管理的，还是云。云的话还要了解一些云服务和产品的内容，比如RDS，负载均衡，内容分发。手机APP这样的产品需求跨平台性以及其他细节问题。 技术特性技术的生命周期：技术生命周期一般就2~3年，服务器操作系统生命周期会更长一些，，关键问题是这个问题本身就不太现实，我们很难预测2~3年以后我们的产品的样子。作为PM你不用了解具体的实现方式，开发效率和健壮性怎么样，是不是符合我现阶段产品开发的需求。 不管怎么说作为PM掌控产品全局你要知道整个项目的技术开发成本是怎样的。程序员是个喜欢创造的工种，如果你只是设计好了让他们照着设计做他们会玩的很没乐趣的。要让他们也参与其中你会发现你的项目会比你想象中的进展要好。 会写代码是加分项；不了解大局上来就聊代码，是越俎代庖,你需要知道水可以用来泡茶，做汤。不需要知道水是H2O,水有哪些种类，什么水泡茶最好，什么水做汤更赞。忌不懂技术,忌懂技术. https://www.codecademy.com/zh/ 对技术架构或某些技术问题的看法，立刻遭到赞扬：“你很懂技术嘛！”这时马上打着哈哈说：“懂个p啊，我连hello world都不会写，完全是纸上谈兵。”于是嬉笑声中，一群人把手里的箭收起来了。 产品经理懂技术 ＝ 流氓会武术。 你怎么实现我不管，我就要这个这个功能不就是xxx么，你直接说要多久把这次的需求很简单，只要做xxx就行了，prd你看下哈你的产品架构，其实也是技术架构！一定不能乱前端要做哪些？字段、样式、交互（操作前、操作中、操作后）、边界条件（字数、图片尺寸等等对前端说：我们这边新增了哪几个页面，ui设计稿什么样的，交互是什么样的…前端done!对后段说：我们这次的产品大逻辑什么，新增了哪些字段，最重要和复杂的逻辑是哪些，可能要哪边的接口，那边的技术已经帮你找好了….后端done!对qa说：这次的迭代和之前有什么不同，最重要的测试点是什么，有哪些风险要测下，回头上线的时候跟我说下我们一起看下…qa done! http://www.cnblogs.com/dunnice/articles/2733430.html 前端=html+css+js=&gt;结构+字段+样式+交互程序=算法+数据结构https://www.zhihu.com/question/26743347https://www.zhihu.com/question/21380252数据驱动产品的发展～ 不同系统的兼容性问题不同版本的兼容性问题 不同屏幕尺寸的兼容性问题 android 和 ios 系统的规范 android 和 ios 打包发布流程 ‘技术无法实现’的潜台词可能是给的资源不够， 完成不了你的优先级低， 不想给你做看你不爽， 不想给你做这功能太傻不应该做最后才是真的技术无法实现 HTML5和NATIVE的特点和区别，哪些在微信中能做，哪些不能做 如果你知道如果将用户的操作分成0.01秒为单位的节点，并将所有的用户行为都预测出来。你就是产品经理。 在一个项目里面 产品经理看懂一个api 难道不是只要看api说明就行了 为什么要懂技术你知道了 都能做什么 然后不就是你排列组合的天下了如果你看的api没说明 让程序员补去","categories":[{"name":"产品设计","slug":"产品设计","permalink":"https://stanye.com/blog/categories/产品设计/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://stanye.com/blog/tags/PM/"}]},{"title":"产品经理沟通技巧(pdf)","date":"2018-05-10T11:07:10.000Z","path":"2018/05/10/communicate-with-product-manager-pdf.html","text":"之前做了《产品经理与程序员和谐相处之道》的ppt分享，此处是导出pdf格式. 百度网盘提取地址 提取码: m5mg","categories":[{"name":"产品设计","slug":"产品设计","permalink":"https://stanye.com/blog/categories/产品设计/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://stanye.com/blog/tags/PM/"},{"name":"ppt","slug":"ppt","permalink":"https://stanye.com/blog/tags/ppt/"}]},{"title":"产品经理如何与技术沟通","date":"2018-05-10T11:07:10.000Z","path":"2018/05/10/communicate-with-product-manager.html","text":"产品经理应该：提出来 讲明白 说服他 验收好 核心的竞争优势就是在技术方面，这个是非技术出身的产品经理最缺的一项技能。技术出身的产品经理跟工程师沟通会比较顺畅，能够深刻体会并理解工程师的思维，提出的设计和需求也会比较接地气，因此不容易跟开发人员产生矛盾。需求策划方面，每一个需求功能点的提出，技术出身的产品经理都可以很快评估出技术实现的可行性，实现所需的大概时间，技术存在的一些风险或问题，因此可以很快将需求点落到实处，大大缩短需求到实现转化所需的周期。 工程师的思维跟产品经理的思维，关注点和考虑问题的方式存在很大的区别。会太注重并纠结技术层面的问题，而忽视了产品经理应该关注的是整个产品项目的大局。产品前期的设计才是整个项目的重心，后面的运营推广是项目成败的关键。市场及商业嗅觉不敏感，产品设计，运营推广等领域缺乏相关的经验，这方面需要投入大量的时间去培养与磨炼，比如商业嗅觉的培养，数据运维的数据分析，营销推广的策划和布局，这些都不是一朝一夕可以练好的内功，需要基于大量的阅读学习，观察及实操后一步步磨炼出来。 在产品大方向的把握，设计细节的考量，运营推广思路上面会存在非常多的盲区，导致对整个项目的理解不够透彻 产品经理在项目推进过程中需要面对老板，工程师，设计师，测试人员，运营，市场等各个领域的人，应该学会换位思考，站在各个不同角色的人的立场去考虑问题，才能协调到更多的资源去配合你完成项目的推进工作。 不要花太多的时间去纠结或花在研究技术上面，而应该把自己的时间合理地分配到其他的技能的学习上面。产品经理是一个对综合能力要求特别高的职位，需要不断地学习，不断地吸收这个领域的知道养分。不要因为“技术”这棵小树，而放弃了产品的这座大森林。 做技术时，你经常需要面对的问题是如何解决技术难题；而做了产品，你所面对的大多数问题是如何搞定人。比如，老板提了一个不合理的需求，你应该怎么婉转地打掉；UI设计师跟你闹矛盾，你怎么让她继续配合你工作；项目资源紧缺，开发周期赶不及，你如何才能申请到更多的资源。除了知识面需要扩充好几倍外，做人做事的能力，也要迅速跟上。 找准自己的定位，分析自己之于团队的价值。沟通是一门艺术。艺术源自生活，不必刻意追求。先试着让身边的人快乐。 程序考虑问题的出发点大多是：体现自己的技术水平。 我接触的程序员喜欢用高效、简单、先进的技术手段解决问题。通常他们反驳产品都是想令代码更简单更高效，而产品却变得复杂、多步骤甚至多余。产品都希望把简单留给用户，把复杂留给开发。这是个对立面。所以程序员转产品，首先要改变自己的思维，从用户和需求出发，而不是从技术角度. 产品工作是感性的，做出一款产品与做出一款好产品的差别无比巨大，大部分所谓的产品经理只能说在从事着一份工作而已，得到个好听又最容易被人吐槽的名头，不代表他真的很厉害. 马化腾(Pony)，张小龙，周鸿祎都是程序员出身的、中国最优秀的互联网产品经理。只有当你跨越了傻瓜心态之后，才算是迈出了成功转型产品经理的第一步。 你永远不要假设用户是聪明的，用户的弱智程度永远超出你想象力的下限。所以，当你设计产品的界面和交互的时候，一定不要拿自己的经验去想当然，一定要假设是在给一个弱智做产品，尽量简化，让产品非常易用才行。 真正好的产品经理应该是以结果为导向的. 技术人员如果没有追求完美的心，就无法成为一个优秀的技术人员。然而带有「完美主义综合症」的产品经理是可怕的。 在这个产品经理，视觉设计，程序员共同参与的产品生产过程中，程序员是最后的环节，当程序员在代码实现的过程中发现了产品逻辑的错误，或者产品设计的问题，是非常被动的。这个时候程序员再要求产品经理更改设计，修正产品交互逻辑，产品经理通常的反应就是：「程序员又和我讨价还价，产品deadline又要延后了」，跟着双方就开始剑拔弩张的对峙。 产品经理负责搜集和定义产品需求，整理产品逻辑规则，设计产品原型稿和交互，这个阶段并不需要程序员开始写代码，但是从一开始就让程序员，运营，甚至运维工程师都参与进来 程序员从一开始就了解了产品的来龙去脉，对产品需求和产品要达到的目标非常清楚，这样在和产品经理的配合中，就非常容易理解产品经理提出的很多功能要求，沟通起来非常顺畅；程序员从一开始就参与，并且持续参与产品设计的过程，最大的好处在于从一开始就可以纠正可能出现的产品设计逻辑错误，以及评估技术难以实现的产品功能。这样等到真正进入开发阶段，研发周期是非常可控的，基本不会出现延误。一些有良好产品意识的程序员，可以帮助产品经理从一开始就完善产品逻辑，从实现上修正产品可能遇到的问题，让产品开发过程变得更加有保障。很多产品经理犯的一个重大错误就是：直到原型稿交互稿定稿之后，才交给程序员，之前全无沟通，然后逼着程序员立刻评估一个精确的开发周期。这个时候程序员内心是非常抗拒的。一来我完全不了解这个产品，不知道做这个产品是干啥的？能够解决什么问题？是否有更好的替代解决方案；二来我也不清楚这个产品逻辑是否有需要调整和修正的地方，以及有些技术上需要投入很多资源但是不划算的功能。 产品经理应该传递一个信息：产品是大家的，需要大家共同合作，一起努力把产品做好，无论是产品，视觉，研发，还是运营，大家都是为了一个共同的目标而努力。 不需要懂技术，但是逻辑要严谨 Bug修好了程序就会马上运营，程序员可以接着下一个代码的编写，但是先生生活中可能不太一样，刚吵完一架，可能就没法友好的合作了。 如果老板同意说，如果PM加需求，要么就砍掉一个差不多规模的旧的，要么就延长期限，我觉得肯定不会打起来。 戒掉“应该”，“大概”，“也许”，”我想“，”可能“这种模棱两可的词语。 to be continue","categories":[{"name":"产品设计","slug":"产品设计","permalink":"https://stanye.com/blog/categories/产品设计/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://stanye.com/blog/tags/PM/"}]},{"title":"high-concurrency-experience","date":"2018-04-30T06:41:42.000Z","path":"2018/04/30/high-concurrency-experience.html","text":"用户数增长，公司项目遇到并发的难题。网上学习几点如下： 处理高并发的业务逻辑 前端: 异步请求 + 资源静态化 + cdn 后端: 请求队列 + 轮询分发 + 负载均衡 + 共享缓存 数据层: redis + 数据分表 + 写队列 存储: raid阵列 + 热备 网络: dns轮询 + DDOS防护 简而言之就是分区、分表、分库，后端算法优化，公共数据缓存，服务器上负载均衡，前端减少连接数、瘦身 如何学习高并发redis, nginx, keeplive, DRBD, heartbeat这些工具在虚拟机上面跑起来.因为有些工具运行的配置要求太高, 必须多台服务器配合才能完成. 总监那边选型TiDB，已经和老板申报了机器. 模拟高并发tengine 公司内则用php写了一些针对要测试的功能点的脚本 如何向别人吹我们的系统 采用了复杂的分层方案，以保证良好的性能和水平扩展性。要点如下: 动静分离: 通过CDN系统分发静态资源: js, css, 图片, 音频, 视频等资源 应用集群: 通过负载均衡技术，实现的应用服务器集群，具有很高的并发处理能力和扩展性。可以根据实际需要迅速扩充服务器，部署应用之后即可直接上线提供服务。 缓存集群: 通过一致性Hash算法实现实现缓存分片，保证缓存系统的响应速度和可扩展性。通过主从复制，保证缓存系统的可靠性。 读写分离: 读写分离，保证两者都具有具有良好的性能。采用写直达技术，保证缓存和数据库数据的一致性。 数据库集群: 采用分布式数据库集群技术（垂直和水平切分技术，复制技术），保证数据库系统的性能、稳定性和可扩展性。 消息队列和辅助任务集群: 长时间运行的任务，先入队列，再由系统调度到后台任务集群中运行，可保证前端页面的响应性能，并为大型的分析作业提供运行环境，并具有很高的扩展能力。 充分测试: 持续集成: 持续的自动化测试。 压力测试: 系统功能模块在上线之前，会经过充分的性能和压力测试，只有在功能、性能和吞吐量达到预期设计指标后，才会上线运行。 部署和监控方案: 红蓝部署: 保证系统升级和发布的稳定性，出现问题时，可迅速回退。 容灾机制: 自动备份机制，降低灾难性事件（如自然灾害等）对系统的影响。 监控方案: 完善的自动监控和报警方案，可以提前发现和报告异常情况，并提醒运维团队及时处理相关问题。","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://stanye.com/blog/tags/redis/"},{"name":"nginx","slug":"nginx","permalink":"https://stanye.com/blog/tags/nginx/"}]},{"title":"rm-input-type-number-arrows","date":"2017-06-05T07:18:18.000Z","path":"2017/06/05/rm-input-type-number-arrows.html","text":"移除input type=number的箭头 css1234567891011// chromeinput::-webkit-outer-spin-button,input::-webkit-inner-spin-button &#123; -webkit-appearance: none !important; margin: 0;&#125;// firefoxinput[type=\"number\"] &#123; -moz-appearance:textfield;&#125; 不用type=number将type=&quot;number&quot;改为type=&quot;tel&quot;, 同样是数字键盘，但是没有箭头。","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"css","slug":"css","permalink":"https://stanye.com/blog/tags/css/"}]},{"title":"Vue更新数组状态方法","date":"2017-05-16T06:58:53.000Z","path":"2017/05/16/vue-update-array.html","text":"直接修改数组检测不到变化：12vm.Arr[index] = newItem;vm.Arr.length = newLength; 由于JavaScript的限制，采用以下方法: 1234// way 1Vue.set(old.Arr, index, newItem);// way 2old.Arr.splice(index, 1, newItem);","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://stanye.com/blog/tags/vue/"},{"name":"array","slug":"array","permalink":"https://stanye.com/blog/tags/array/"}]},{"title":"mysql查重","date":"2017-05-03T06:30:20.000Z","path":"2017/05/03/mysql-duplicate-checking.html","text":"mysql查重： 单字段1select * from member where mobile in (select mobile from member group by mobile having count(mobile) &gt; 1) 单字段查重删除1delete from member where mobile in (select mobile from member group by mobile having count(mobile) &gt; 1) and rowid not in (select min(rowid) from member group by mobile having count(mobile)&gt;1) 多字段1select * from member a where (a.mobile,a.email) in (select mobile,email from member group by mobile,email having count(*) &gt; 1) 多字段查重删除1delete from member a where (a.mobile,a.email) in (select mobile,email from member group by mobile,email having count(*) &gt; 1) and rowid not in (select min(rowid) from member group by mobile,email having count(*)&gt;1)","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://stanye.com/blog/tags/mysql/"}]},{"title":"php&引用","date":"2017-04-29T11:10:39.000Z","path":"2017/04/29/php-cite.html","text":"php的引用–在变量或者函数、对象等前面加上&amp;符号,允许两个变量来指向同一个内容123456$a = \"111\";$b = &amp;$a;echo $a; // 这里输出:111echo $b; // 这里输出:111$b=\"222\";echo $a; // 这里$a的值变为222 所以输出222 echo $b;//这里输出222 ￼ 1234567function demo(&amp;$a)&#123; $a = $a + 1;&#125;$b = 100;echo $b; // 100demo($b); //$b的内存地址echo $b; // 101 123456function &amp;test()&#123; static $b=0;//申明一个静态变量 $b=$b+1; echo $b; return $b;&#125;","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"php","slug":"php","permalink":"https://stanye.com/blog/tags/php/"}]},{"title":"使用using关键字对连接进行简化","date":"2017-04-29T06:39:10.000Z","path":"2017/04/29/sql-using.html","text":"USING进行简化： 1、查询必须是等连接的 2、等连接中的列必须是同名123select aname, bname from a inner join b using(category) 在使用using是需要注意以下几个问题 1、在select子句中只能指定该列名，不能使用表名或别名 2、在using子句中也只能单独使用列名对于多与两个表的连接12345select c.c_name, p.p_name , f.f_namefrom ctable c, ptable p, ftable fwhere c.user_id = f.user_idand p.p_id = f.p_id and p.type_id = f.type_id; 使用using对上面的sql语句进行重写 1234567select c.c_name, p.p_name, f.type from ctable c inner join ftable f using(user_id) inner join ptable p using(p_id) inner join ftable f using(type_id);","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://stanye.com/blog/tags/mysql/"},{"name":"using","slug":"using","permalink":"https://stanye.com/blog/tags/using/"}]},{"title":"mysql-simple-usage","date":"2017-04-28T06:16:57.000Z","path":"2017/04/28/mysql-simple-usage.html","text":"连接mysql 1mysql -h&#123;server host address&#125; -u&#123;username&#125; －p&#123;password&#125; 修改密码 1mysqladmin -u&#123;username&#125; -p&#123;oldpassword&#125; password&#123;newpassword&#125; 增加新用户 已经进入mysql 1grant select on &#123;dbname&#125;.* to &#123;username&#125;@&#123;host&#125; identified by &quot;&#123;password&#125;&quot; 但是为了防止host远程可以连接，一般只开放host配置到localhost，即先登录到服务器，再连接本机mysql 常用命令 1234567891011121314151617181920212223242526272829303132// 显示数据库show databases;// 显示表use &#123;某个database&#125;;show tables;// 显示某个表结构desc &#123;表名&#125;;// 建库create database &#123;dbname&#125;;// 建表create table &#123;tablename&#125; (&#123;`id`....,`name`...&#125;);// 删库drop database &#123;dbname&#125;;// 删表drop table &#123;tablename&#125;;// 增删改查等不做赘述// 增加字段alter table dbname add column &#123;字段名&#125;// 修改字段alter table dbname change &#123;字段名&#125; &#123;新字段名&#125;// 删除字段alter table dbname drop column &#123;字段名&#125; 导出数据 1mysqldump &#123;dbname&#125; &gt; jiaoben.mysql","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://stanye.com/blog/tags/mysql/"}]},{"title":"mysql给表赋权","date":"2017-04-04T03:22:52.000Z","path":"2017/04/04/mysql-grant.html","text":"mysql赋权：1grant drop on sch_m.common_member to dev@'localhost'","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://stanye.com/blog/tags/mysql/"}]},{"title":"css两行截取","date":"2017-04-03T08:30:22.000Z","path":"2017/04/03/css-cut-2-line.html","text":"css两行截取解决办法： 12345overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"css","slug":"css","permalink":"https://stanye.com/blog/tags/css/"}]},{"title":"table文字溢出控制","date":"2017-04-03T04:30:22.000Z","path":"2017/04/03/css-fix-table-wrap.html","text":"table换行解决办法： 1234567891011table &#123; width:100px; table-layout:fixed;&#125;td &#123; width:100%; word-break:keep-all; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;&#125;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"css","slug":"css","permalink":"https://stanye.com/blog/tags/css/"},{"name":"table","slug":"table","permalink":"https://stanye.com/blog/tags/table/"}]},{"title":"php file_put_contents 函数","date":"2017-03-28T01:21:11.000Z","path":"2017/03/28/php-file_put_contents.html","text":"file_put_contents()功能函数（集成了fopen、fwrite、fclose) 将一个字符串写入文件.1int file_put_contents ( string filename, string data [, int flags [, resource context]] ) 和依次调用 fopen()，fwrite() 以及 fclose() 功能一样。参数 data 可以是数组，这就相当于 file_put_contents($filename, join(‘’, $array)) filename 要被写入数据的文件名。 data 要写入的数据。类型可以是 string，array 或者是 stream 资源（如上面所说的那样）。 flags 可以是 FILE_USE_INCLUDE_PATH，FILE_APPEND 和／或 LOCK_EX（获得一个独占锁定），然而使用 FILE_USE_INCLUDE_PATH 时要特别谨慎。 context 一个 context 资源。","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"php","slug":"php","permalink":"https://stanye.com/blog/tags/php/"}]},{"title":"sql note","date":"2017-03-27T10:30:22.000Z","path":"2017/03/27/sql-join.html","text":"left-join/right join/inner join left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录.right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录. inner join(等值联接) 只返回两个表中联结字段相等的行. left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录.B表记录不足的地方均为NULL.LEFT JOIN操作用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，即使在第二个（右边）表中并没有相符值的记录 right join和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充. inner join并不以谁为基础,它只显示符合条件的记录 limit 取出第一条记录。 1select * from tablename limit 0,1 第二条记录 1select * from tablename limit 1,1 从第11条到31条（共计20条） 1select * from tablename limit 10,20","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://stanye.com/blog/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://stanye.com/blog/tags/sql/"}]},{"title":"php抽象类","date":"2017-03-27T06:56:20.000Z","path":"2017/03/27/php-abstract-class.html","text":"php抽象类: PHP5支持抽象类和抽象方法。 抽象类不能被实例化，必须先继承再实例化。 继承抽象类, 子类必须全部实现抽象类中的方法, 而且public、private、protected只能高不能低 12345678910111213141516171819202122232425262728293031323334353637383940abstract class AbstractClass&#123; // 强制要求子类定义这些方法 abstract protected function getValue(); abstract protected function prefixValue($prefix); // 普通方法（非抽象方法） public function printOut() &#123; print $this-&gt;getValue; &#125;&#125;class ConcreteClass1 extends AbstractClass&#123; protected function getValue() &#123; return \"ConcreteClass1\"; &#125; public function prefixValue($prefix) &#123; return \"&#123;$prefix&#125;ConcreteClass1\"; &#125;&#125;class ConcreteClass2 extends AbstractClass&#123; public function getValue() &#123; return \"ConcreteClass2\"; &#125; public function prefixValue($prefix) &#123; return \"&#123;$prefix&#125;ConcreteClass1\"; &#125;&#125;$class1 = new ConcreteClass1;$class1-&gt;printOut();echo $class1-&gt;prefixValue('FOO_') .\"\\n\";$class2 = new ConcreteClass2;$class2-&gt;printOut();echo $class2-&gt;prefixValue('FOO_') .\"\\n\"; 以上例程会输出： ConcreteClass1 FOO_ConcreteClass1 ConcreteClass2 FOO_ConcreteClass2 抽象类的子类中的普通方法执行方式和其他类相同","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"php","slug":"php","permalink":"https://stanye.com/blog/tags/php/"},{"name":"abstract class","slug":"abstract-class","permalink":"https://stanye.com/blog/tags/abstract-class/"}]},{"title":"jQuery判断页面滚动到底/到顶","date":"2016-09-30T07:12:19.000Z","path":"2016/09/30/jquery-scrollTop.html","text":"概念12345678// 垂直滚动条$(document).scrollTop()// 水平滚动条$(document).scrollLeft()// 页面高度$(document).height()// 浏览器窗口高度$(window).height() 实现1234// 到顶$(document).scrollTop() == 0// 到底$(document).scrollTop() &gt;= $(document).height() - $(window).height()","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://stanye.com/blog/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://stanye.com/blog/tags/javascript/"}]},{"title":"regex in my program","date":"2016-07-15T03:41:43.000Z","path":"2016/07/15/regex-used.html","text":"用到的一些正则记录： 匹配&gt;&lt; &gt;[\\s]+&lt; 匹配反斜杠(匹配一个反斜杠要用四个反斜杠) 1\\\\\\\\ 字符串里面表示斜杠就需要两个斜杠\\\\ 正则表达式里的斜杠需要转意，是用\\\\标示。 第一个斜杠是转义符，第二个斜杠是斜杠本身，第三个斜杠是转义符，第四个斜杠是斜杠本身 密码校验 1public static final String PASSWORD_PATTERN = \"^(?![a-zA-z]+$)(?!\\\\d+$)(?![!\\\"#$%&amp;#$%&amp;amp;'()*+,-./:;&amp;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@\\\\[\\\\]^_`&#123;|&#125;~]+$)[a-zA-Z\\\\d!\\\"#$%&amp;#$%&amp;amp;'()*+,-./:;&amp;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@\\\\[\\\\]^_`&#123;|&#125;~]&#123;6,16&#125;$\"; input标签验证 123456789101112131415161718// 只能输入英文&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^a-zA-Z]/g,'')\" /&gt;// 无法粘贴&lt;input type=\"text\" onkeydown=\"fncKeyStop(event)\" onpaste=\"return false\" /&gt;// 屏蔽右键&lt;input type=\"text\" oncontextmenu=\"return false\" /&gt;// 只能输入数字&lt;input type=\"text\" onkeyup=\"this.value=this.value.replace(/\\D/g,'')\" /&gt;// 只能输入数字，小数点：&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\d\\.]/g,'')\"&gt; /&gt;// 只能输入数字，小数点，下划线：&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\d\\._]/g,'')\" /&gt;// 只能输入汉字：&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\u4E00-\\u9FA5]/g,'')\" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\u4E00-\\u9FA5]/g,''))\"&gt;// 禁止输入法输入：&lt;input type=\"text\" style=\"ime-mode: disabled\"&gt;","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"regex","slug":"regex","permalink":"https://stanye.com/blog/tags/regex/"}]}]