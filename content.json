[{"title":"何为低代码平台","date":"2019-10-09T12:42:55.000Z","path":"2019/10/09/what-is-low-code-platform.html","text":"what is low code platform ？ 前言 从去年年底开始，公司提出了一个构想，通过拖拽各种组件的方式，快速生成页面，满足普遍性的需求，同时缩短开发的人力成本。 于是从年初开始，我一直在做一个内部的“低代码”的平台, 代号叫“lego”. 什么是“低代码” 低代码开发平台，是指那些无需编码或通过少量代码就可以快速生成应用程序的工具，其一方面可以降低企业应用开发人力成本，另一方面可以将原有数月甚至数年的开发时间成倍缩短，从而帮助企业实现降本增效、灵活迭代的价值。 本段出自36kr 我的解释：有一群专业的人做了一个很cooooool的《我的世界》，让不会写代码的人也能做出别人羡慕的《别人的世界》 Lego前身 培训宝-移动学习配置 我在的上家公司（没准马上是EXEX家），需要做一个给用户自定义移动端主页的功能。一阵开发之后，前端用jQuery实现组件选择、配置，提交保存给后端。后端我用PHP分门别类，将每个数据，每个类型存在不同表里面。移动端用户进入页面，读取配置，用Vue按配置的顺序渲染页面。至于配置的时候实时预览呢？iframe套移动端页面 + iframe.reload() 技术栈：jQuery + PHP + Mysql + Vue Demo年初我在当前公司也提出了这个构想。老大说让试试看，但是仅限于前端部分，让我可以脱离后端来完成（可行性试验阶段，不需要完整开发）。 页面配置 页面预览 算是实现了一个页面配置，一个页面展示。那时候公司业务正如火如荼，这个demo让大家萌生了很多概念，觉得非常cooooool~~ 技术栈：React + AntD + localStorage + koa（后废弃，发现完整实现前后端有点费工时） LegoJSON配置文件首先我们定义了JSON配置文件，类似json schema，老大称之为Lego DSL（Lego领域特定语言）。 123一切配置的最终目标是生成这份JSON.一切渲染是以这份JSON为基础.一切组件和行为库要满足JSON的数据格式与规范. 这是lego的血 核心渲染引擎Lego/core@lego/core就是一个引擎库, 外部import lego/core以后，通过react-router的render，加上传入配置，最终渲染出页面。 1234...import &#123;Lego&#125; from '@lego/core';...&lt;Route path=\"/page\" render=&#123;() =&gt; &lt;Lego legoNamespace=\"components\" legoId=\"components\" /&gt;&#125; /&gt; 这是lego的心 组件库Lego/component通过对Ant Design二次封装，配置出了满足lego/core要求的组件库。 可以显示隐藏、可以监听数据变化这是lego的身体 组件库Lego/behavior有了样子（component）还不够，还要有行为。这个页面进来要干什么，这个组件要干什么，某个值发生变化的时候怎么影响另一个值？ 这是lego的魂 有了以上几个部件，到五月份的时候，通过手写一段合乎我们规范的JSON文件，已经可以生成一个页面。我们内部做了分享，定下来接下来的GUI计划。 技术栈：Dva、Lodash、Ant Design Lego-CanvasLego的配置平台 Canvas画布，也就是所谓的实时预览。最开始的iframe + iframe.reload, 后来通过dva（redux状态管理）做到了动态无缝加载（类似Hmr）。 ComponentTree组件树。展示了当前页面所有组件的嵌套。基于Ant Design Tree组件。 ComponentConfig组件配置。前期整理的Component库，每个配置项都通过Ant Design Form实现表单配置。行为配置？由RYZ同学通过D3,把一个个非常复杂的逻辑用圈和线连接的方式，给画了出来，有点像流程图的感觉。 Lego-canvas 我们也实现了组件之间的复杂联动, 禁用启用, 自定义组件 总结做这个项目耗费了差不多三个季度，然尔期间公司业务转GIS、Bim、G3d，我做这个项目最需要的场景，已经不复存在了。 我脑补中的“竞品” 云凤蝶 飞冰 Lugia UForm Gen pipeline 部分参考资料 https://github.com/CntChen/cntchen.github.io/issues/15 https://yq.aliyun.com/articles/112472?utm_content=m_24509 https://juejin.im/pin/5d4966b751882564daa2f60d To be continued","categories":[{"name":"产品设计","slug":"产品设计","permalink":"https://www.stanye.com/blog/categories/产品设计/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://www.stanye.com/blog/tags/PM/"}]},{"title":"同步git本地分支和远程分支","date":"2019-07-29T02:28:32.000Z","path":"2019/07/29/sync-git-local-branch-with-remote-branch.html","text":"git branch的时候看到一大堆分支，感觉想全部干掉. 查看分支 123456// allgit branch -a// localgit branch// remotegit branch -r 查看本地分支和追踪情况 1git remote show origin 出现stale (use &#39;git remote prune&#39; to remove) 删除远程上的 1git remote prune origin 删除本地的 12// 正常操作 强制删除用-Dgit branch -d lalala","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://www.stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.stanye.com/blog/tags/git/"},{"name":"git branch","slug":"git-branch","permalink":"https://www.stanye.com/blog/tags/git-branch/"}]},{"title":"mac更新系统引发apache403问题","date":"2019-07-19T07:18:32.000Z","path":"2019/07/19/how-to-fix-apache-403.html","text":"今天无意中发现apache服务启动不起来，一直报403的错误。 apache 403百度几个方案，都无法解决，最终在Mac OS下开启自带的apache服务文章里，解决： 因为Mac版本升级导致了apache策略发生变更了，所以我们修改后还是会出现403无权访问的情况。解决方法:备份原有的httpd.conf配置文件,把同级目录下的httpd.conf.pre-update 重命名为httpd.conf其他配置照搬之前的（网站文档目录及端口ServerName的配置） 重启遇到的两个问题AH00557: httpd: apr_sockaddr_info_get() failed for…AH00558: httpd: Could not reliably determine…When restart the httpd. Try: 1sudo /usr/sbin/apachectl restart Don’t use: 1sudo apachectl restart 为什么会出现类似的问题呢因为你电脑装了两个不同版本的Apache 如果还有问题?修改/etc/apache2/httpd.conf将#ServerName www.example.com:80的注释去掉可以换成自己定义的域名","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://www.stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"apache","slug":"apache","permalink":"https://www.stanye.com/blog/tags/apache/"},{"name":"MacOS","slug":"MacOS","permalink":"https://www.stanye.com/blog/tags/MacOS/"},{"name":"Mojave","slug":"Mojave","permalink":"https://www.stanye.com/blog/tags/Mojave/"}]},{"title":"面试知识点整理","date":"2019-06-18T05:03:25.000Z","path":"2019/06/18/interview-part1.html","text":"持续更新 CSSBFC是啥BFC是block format context, 块级格式化上下文 作用: 为了让内部元素和外部隔离 触发条件(什么情况下创建BFC): 根元素 &lt;html&gt; 浮动元素 float不是none 绝对定位 position是absolute OR fixed overflow不是visible 弹性布局display: flex 网格布局display: grid display: flow-root 应用: 阻止margin重叠 清除浮动 自适应两栏布局 浮动原理及清除浮动原理: float将元素从文档流中脱离（position:absolute也是脱离文档流） 清除: 123&lt;br/&gt;&lt;div style=\"clear: both\"&gt;&lt;/div&gt; 1234.parent:after &#123; clear: both; content: ' '&#125; 垂直居中布局1. 123456.box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 2. 1234567.box &#123; position: absolute; top: 50%; width: 100px; left: 50%; margin-left: -50px;&#125; 3. 12345.box &#123; display: flex; align-items: center; justify-content: center;&#125; 4. 12345678910.box &#123; position: absolute; width: 100px; height: 50px; top: 0; left: 0; right: 0; bottom: 0; margin: auto;&#125; 修改元素定宽 max-width: 300px width: 300px !important scale()缩放 懒加载LazyloadgetBoundingClientRect() opacity: 0 | visibility: hidden | display: none 区别opacity: 0 透明度0, 影响下级, 可以点击, 占空间visibility: hidden 隐藏，不影响下级(下级设置可见), 占空间, 本元素重绘display: none 不显示, 影响下级, 渲染不占空间, 不可点击, 造成文档回流 回流和重绘多行省略1.单行12345678910.box &#123; overflow: hidden; text-overflow: ellipsis; /* 单行 */ white-space: nowrap; /* 多行 */ display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; string截取str.slice()str.substring() 盒模型box-sizing: border-box(IE盒模型) | content-box(标准盒模型) VueMVVMvue-transitionReact虚拟DOM(virtual Dom)虚拟DOM是真实DOM的内存表示，UI的表示形式存在内存里，与实际DOM同步。 class组件和function组件区别class组件： 使用必须在声明后 无状态组件和状态组件 有this内部属性 内部为严格模式 内部属性不可枚举function组件： 无state, 无生命周期, 没有this React Hook和的区别&lt;Link&gt;利用diff算法，局部更新，减少了DOM的性能消耗，静态跳转&lt;a&gt;重新渲染，router动态跳转 合成事件和原生事件的区别合成事件是最终绑定在document上，简化了DOM操作和内存开销有自己的SyntheticEvent冒泡阶段中的事件触发，中断的话只能用preventDefaultstopPropagation 不能中断 异常捕获 react ComponentDidCatch window.onerror try catch JavaScript[1, 2, 3].map(parseInt) || [1, 2, 3].filter(parseInt)123456[1, 2, 3].map(parseInt);parseInt(1, 0) // 1parseInt(2, 1) // NaNparseInt(3, 2) // NaN// [1, NaN, NaN] 123456[1, 2, 3].filter(parseInt);parseInt(1, 0) // 1parseInt(2, 1) // NaN ==&gt; falseparseInt(3, 2) // NaN ==&gt; false// [1] 防抖和节流防抖123456789101112function debounce(fn, delay) &#123; let timer = null; return function(...args) &#123; var context = this; if (timer) clearTimeout(timer); setTimeout(function() &#123; fn.apply(context, args); &#125;, delay) &#125;&#125; 节流1234567891011121314function throttle(fn, delay) &#123; let timer = null; return function(..args) &#123; let context = this; if (!timer) &#123; timer = setTimeout(function() &#123; fn.apply(context, args); timer = null; &#125;, delay); &#125; &#125;&#125; Set | Map | WeakSet | WeakMapSet 集合 值唯一12345678Set.length === 0 Set.prototype.addSet.prototype.clearSet.prototype.deleteSet.prototype.entriesSet.prototype.forEachSet.prototype.hasSet.prototype.value WeakSet 只能放对象引用，不能放值, 不可枚举，弱引用1234WeakSet.prototype.addWeakSet.prototype.clearWeakSet.prototype.deleteWeakSet.prototype.has Map 字典, 初始化可以放二元数组, 键名可以任意值（Object只能放string和Symbol）1234567Map.prototype.sizeMap.prototype.clearMap.prototype.deleteMap.prototype.entriesMap.prototype.forEachMap.prototype.getMap.prototype.set WeakMap 键名必须是对象，弱引用，不可枚举，故时间复杂度低1234WeakMap.prototype.hasWeakMap.prototype.getWeakMap.prototype.setWeakMap.prototype.delete 数组去重const arr = [1, 2, 1, 4, 3]; 1const newArr = Array.from(new Set(arr)) 2.1const newArr = [...new Set(arr)] 3.1234567891011let newArr = [];let map = new Map();for (let i = 0; i &lt; arr.length; i++) &#123; if (map.has(arr[i])) &#123; map.set(arr[i], true); &#125; else &#123; map.set(arr[i], false); newArr.push(arr[i]); &#125;&#125; 4.1234const newArr = [];for (let i = 0; i &lt; arr.length; i++) &#123; !newArr.includes(arr[i]) &amp;&amp; newArr.push(arr[i])&#125; for…of || for…in隐式转换坑好大，待完善 ToPrivar 严格模式原型prototype柯里化柯里化：暂存，等到参数长度为0的时候执行 判断类型的几个方法123456789101112131415var a;// typeoftypeof null // \"object\"typeof [] // \"object\"// instanceof 判断构造函数的原型是否在对象的原型链上var a = [];a instanceof Array // true// Object.prototype.toSting法对于自定义的构造函数仍然无效Object.prototype.toSting.callReflect.apply(Object.prototype.toSting, null , []);Array.isArray()nodeType === 1 元素 数据类型原始类型Number String Null Undefined Boolean Symbol BigIntNumber 最大2^53BigInt 大于2^53 111111111n 后缀n表示bigint引用类型object null和undefined区别null 描述空值，对象的值未设定, 空指针， typeof null === ‘object’undefined 预定义的全局变量，表示未定义, typeof undefined === ‘undefined’ 模块化 IIFE(立即执行函数) 123(function() &#123;&#125;)() AMD 123define('./index.js', function() &#123;&#125;) CMD CommonJS ES6 Modules 如何编写可复用组件组件构成propseventsslots 组件间通信无关业务命名不能包含业务，最好有自己独立的命名空间只负责UI和交互，内部只处理数据，不获取数据不要从内部操作$parent尽量减少对外部的依赖（不要过分拆分一个功能）数据扁平化，不要依赖一个对象什么的不要太复杂，越简单越容易复用 正则表达式表达式\\ 转义^ 起始 当在[]集合中出现表示非$ 结尾* 匹配前一个表达式0次或多次 {0, }+ 匹配前一个表达式1次或多次 {1, }? 匹配前一个表达式0次或1次 {0, 1}. 匹配除换行符之外的任何单个字符(x) 捕获括号(?:x) 非捕获括号x|y 匹配x或y先行断言 x(?=y)后行断言 (?&lt;=y)x{n} 匹配前面字符出现n次[xyz] 字符集[^xyz] 反向字符集\\b 匹配一个词的边界\\d 匹配一个数字 [0-9]\\D 匹配一个非数字 [^0-9]\\s 匹配一个空白\\S 匹配一个非空白\\w 匹配一个单字字符（字母、数字或者下划线）[A-Za-z0-9_]\\W 匹配一个非单字字符[^A-Za-z0-9_]\\n 返回捕获的第n个 方法exec match test matchAll replace split 标志g 全局i 不区分大小写s 多行 浮点数运算0.1 + 0.2 === 0.3 // false 0.1 + 0.2 // 0.30000000000000004 相加会先转二进制，浮点数转二进制无穷。由于64位双精度浮点数的小数部分最多支持53位二进制位 12var a = 0.1, b = 0.2;var res = (a * 10 + b * 10) / 10; toFixed() cookie | localStorage | sessionStoragecookie 4kb安全性：Cookie被截获（抓包）、泄露（解析后）、XSS（利用script获取cookie）、csrf(跨站访问) HTTPS JWT（signature） 过滤脚本 inline-block间隙原理：inline-block是把元素放一行，但是由于有换行符，导致中间有空隙 font-size：0 两个子元素一行 float，要清除浮动 new到底是什么new是一个运算符，调用构造函数Function来创建函数，创建对象实例 Cat 继承 Animal123456789101112131415161718function Cat() &#123;&#125;function Animal() &#123; &#125;// 1 改写Cat为class// 2 构造函数绑定function Cat() &#123; let args = Array.prototype.slice.call(arguments); Animal.apply(this, args);&#125;// 3Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat; this指向 默认调用（插件当前调用环境） 隐式调用（谁调用指向谁） 显示绑定 call apply bind new绑定 this指向new出来的对象 箭头函数的this（查找函数所处的作用域） 优化 合并循环中的DOM操作 合并样式操作 先脱离文档流，操作完成再放回去 事件委托，每个元素的事件绑定放到父节点上 减少资源大小html、css、js、图片压缩 减少请求次数（1.图片合并 2.公共库合并 3. 不同页面单独合并） 合理使用缓存（CDN、http缓存） 模块按需加载 资源懒加载 资源预加载 CommonsChunkPlugin webpack4移除。splitChunks 动态导入 import tree shaking 也就是uglifyjs 多域名增加请求次数 js放在底部 减少回流（重排）和重绘 defer async Promiseasync/await12345678async function () &#123; await fn();&#125;// [return value] = await expression;// expression: 一个promise对象或者任意返回值// return value 返回处理结果，如果不是Promise对象，返回该值本身 await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。await 是一个让出线程的标志, 后面的函数会先执行一次;看后面函数的返回值，如果返回不是promise，则继续执行async函数后面的代码，哪怕外面已经有任务队列在排队;否则将返回的promise，放入microtask队列, 然后等待promise任务队列执行完之后，再执行await后面的代码 XMLHttpRequest123456789var xhr = new XMLHttpRequest();xhr.open('POST', 'https://developer.mozilla.org/', true);xhr.setRequestHeader('Content-Type', 'application/json');xhr.onreadyStateChange = function() &#123; if (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText); &#125;&#125;xhr.send(); 跨域浏览器同源（protocol、host、port） jsonp请求中定义一段callback函数，将函数名传递过去，后端返回json数据，用函数包裹 安全问题 Webpackentry单页面入口多页面入口 output输出也可以分多个 Loader处理源文件不同格式转换成识别的css和js babel-loadercss-loader 处理css文件中的url()style-loader 将.css代码插入html里&lt;style&gt;stylus-loaderless-loader 处理less文件postCss 预处理css文件 PluginsHTMLWebpackPlugin根据html模板生成目标文件 HMR开发环境动态更新 压缩，优化，缓存，分离css和jsExtractTextWebpackPlugin 提取文件s babel@babel/preset-env预设设置环境，加载core-js babel-runtime 和 babel-polyfill7.4以前 polyfill就是runtime + corejs7.4以后 core-js代替了polyfill babel/runtime 生成不污染全局和内置对象原型的代码 帮助函数移出冗余函数 取消异步请求 XHR xhr.abort() jQuery.ajax ajax.abort() axios axios.cancelToken.source() fetch AbortController 设计模式发布-订阅模式（Sub-Pub） 创建一个对象，作缓存列表 on方法订阅，将callback函数加入列表 emit方法发布，根据arguments里第一个参数当做key，根据key值去执行缓存列表函数 remove根据key值取消订阅 node里的EventEmitter就是一个典型的观察-订阅模式 观察者模式（Observer)当对象存在1对多关系时，使用观察者模式 观察者模式有两个角色，一个是Subject, 一个是Observer 现代浏览器自带的观察者 IntersectionObserver 交叉观察者 观察一个元素在视窗是否可见 懒加载(getBoundingClientRect() 返回元素的大小及其相对于可视窗口的位置,Scroll 和 Resize 事件, getBoundingClientRect会引起页面回流) 视频在可见区域自动播放 observe disconnect MutationObserver 变动观察者 异步触发 ResizeObserver 视图观察者 PerformanceObserver 性能观察者 内存js的内存空间分为栈stack, 堆heap, 池。 V8引擎的内存上限：64位系统是1.4G, 32位系统是 700M 栈存放基本数据类型，自动分配内存空间1var a = 10; // 栈 堆存放引用类型1var b = &#123;m: 10&#125; // &#123;m: 10&#125;放在堆里 b放在内存 池放常量，与栈类似 生命周期 内存分配阶段，声明的时候自动分配 内存使用阶段，读写 内存回收，不用了就由辣鸡回收机制回收 辣鸡回收机制gc回收机制 garbage collection 引用计数 计数器为0就被回收 计数器占空间 循环引用无法回收 标记清除（无法到达的回收掉） 局部作用域在函数执行完成就被回收 作用域const常量为什么能用object的操作const定义的引用类型时，变量保存的是对象的指针，指针不变就可以修改对象","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://www.stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"interview","slug":"interview","permalink":"https://www.stanye.com/blog/tags/interview/"},{"name":"javascript","slug":"javascript","permalink":"https://www.stanye.com/blog/tags/javascript/"}]},{"title":"如何开发油猴脚本来block掘金用户","date":"2019-05-14T15:32:51.000Z","path":"2019/05/14/how-to-develop-tampermonkey.html","text":"随着掘金用户不断增加，或多或少遇到”钢筋”用户。秉着眼不见为净的原则，在官方没有出屏蔽功能的情况下，利用油猴实现block用户。 使用 浏览器安装Tampermonkey扩展 访问脚本网站greasyfork.org安装本扩展 点击页面上脚本扩展的block按钮 https://github.com/stanye/UserScripts 欢迎提issue和PR 实现方法 根据用户id用jQueryremove相关DOM1$(`.username[href=\"/user/$&#123;id&#125;\"]`).parents('.item').remove(); Tampermonkey中使用jQuery1// @require https://code.jquery.com/jquery-3.3.1.min.js 只针对掘金站点1// @include /^https?:\\/\\/(\\w+\\.)?juejin\\.im\\// 用户id 以我的为例 https://juejin.im/user/58f56b4b0ce463006bc084eb58f56b4b0ce463006bc084eb就是id 存储和读取blockList使用localStorage操作, 不做赘述 在页面中加按钮 dropdown-menu action-box 1234const actionBox = $('.user-info-block .action-box');if (actionBox.has('.big-block-btn').length === 0) &#123; actionBox.append(`&lt;button $&#123;scope&#125; class=\"follow-btn btn big-block-btn\" style=\"color: red;\"&gt;Block&lt;/button&gt;`);&#125; scope样式问题掘金用了vue的scope，用jQuery新增的内容想要套用原来的样式需要获取到scope生成的hash 1const scope = $('.user-info-block .action-box')[0].attributes.item(0).nodeName; 给按钮增加点击事件1$('#juejin').on('click', '.block-btn', block); jQuery获取dom早于vue请求数据并渲染123456// 分页$(window).on('scroll', () =&gt; &#123; startClear();&#125;);// 第一次setTimeout(startClear, 1000); 暂时没好想法,先setTimeout和scroll 发布利用github的Webhooks同步发布到greasyfork 初始化import脚本 初始化import脚本 开启webhook并应用 开启webhook并应用 按提示在github仓库的settings -&gt; webhooks创建hook, 每次仓库更新就会同步更新到greasyfork 小结 本意只是脑子一闪而过的idea，并付诸实现。 良好的社区气氛还是需要大家共同努力的。 TODO 覆盖掘金全站的block脚本 针对某条回复的block blockList管理 代码不够优雅，需要去掉硬编码","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://www.stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"tampermonkey","slug":"tampermonkey","permalink":"https://www.stanye.com/blog/tags/tampermonkey/"},{"name":"jQuery","slug":"jQuery","permalink":"https://www.stanye.com/blog/tags/jQuery/"},{"name":"juejin.im","slug":"juejin-im","permalink":"https://www.stanye.com/blog/tags/juejin-im/"}]},{"title":"记录博客切换成gitalk的Error/no Issues问题","date":"2019-05-13T10:05:38.000Z","path":"2019/05/13/switch-to-gitalk.html","text":"常见问题不做累述，记录几个配置心得 太长不看版 我的主域名是www.stanye.com, 我的博客域名是www.stanye.com/blog/, 虽然是给博客申请gitalk, 但是OAuth申请的时候填的的都是https://www.stanye.com/(对应没域名的stanye.github.io) 前言我的博客当前配置: 使用hexo搭建博客 使用的主题是hexo-theme-indigo 使用的valine评论, 想要切换到gitalk 使用了github pages / 使用了自己的域名 / blog仓库不是github pages主仓库 关于gitalkGitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。使用 Github 帐号登录，界面干净整洁，最喜欢的一点是支持 MarkDown语法 主要特性： 使用 Github 登录 支持多语言 [en, zh-CN, zh-TW, es-ES, fr] 支持个人或组织 无干扰模式（设置 distractionFreeMode 为 true 开启） 快捷键提交评论 （cmd|ctrl + enter） 支持MarkDown语法 创建OAuth Application用github账号创建了一个账号应用, 用户授权登录gitalk, 点击申请 以我的域名stanye.com为例 图片 我的主域名是stanye.com, 我的博客域名是stanye.com/blog/, 虽然是给博客申请gitalk, 但是这地方填写的都是https://stanye.com/ 配置因为indigo已经支持gitalk(不支持请更新到最新代码), 需要配置_config.yml 以我的githubgithub.com/stanye/blog为例 12345678gitalk: // github用户名 owner: stanye // 仓库名 repo: blog // 上一步OAuth Application生成的 client_id: b7ecea36c7957fdadfb6 client_secret: 95dddf9298936c42c983f727c2f40c118d30a147","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://www.stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"gitalk","slug":"gitalk","permalink":"https://www.stanye.com/blog/tags/gitalk/"},{"name":"hexo-indigo-theme","slug":"hexo-indigo-theme","permalink":"https://www.stanye.com/blog/tags/hexo-indigo-theme/"},{"name":"hexo","slug":"hexo","permalink":"https://www.stanye.com/blog/tags/hexo/"}]},{"title":"aliyun-centos-fix","date":"2019-04-26T08:22:09.000Z","path":"2019/04/26/aliyun-centos-fix.html","text":"这几天体验了下安骑士, 发现裸奔有些警告, 做了一些修复. 禁止root直接登录 创建一个账号www 修改/etc/ssh/sshd_config, PermitRootLogin改成no 默认登录端口检测修改/etc/ssh/sshd_config, 去掉Port 22注释#，并修改22为其它值 设置用户密码 修改/etc/security/pwquality.conf 去掉minlen注释，设置最小密码长度10 去掉dcredit注释，设置数字位数为负数建议-1(最少包含1位数字) 去掉ucredit注释，设置大写字母位数为负数-1(最少包含1位大写字母) 去掉lcredit注释，设置小写字母位数为负数-1(最少包含1位小写字母) 去掉ocredit注释，设置特殊字符位数为负数-1(最少包含1位特殊字符) 密码时间 修改/etc/login.defs 密码失效时间, 365天 最小间隔时间, 7天","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"centOS","slug":"centOS","permalink":"https://www.stanye.com/blog/tags/centOS/"},{"name":"aliyun","slug":"aliyun","permalink":"https://www.stanye.com/blog/tags/aliyun/"}]},{"title":"使用git rebase对commits进行（合并/拆分/修改作者信息）","date":"2019-04-04T09:55:32.000Z","path":"2019/04/04/use-git-rebase-to-combine-split-resign-your-commits.html","text":"这几天做开源项目，项目负责人对commits要求很高，故总结了合并/拆分commits以及修改提交信息等相关. 1. 对多个commits合并 首先查看历史信息 1git log --oneline 想合并前两条 123git rebase -i Head~2// 或者git rebase -i 33bda27 // 前一条 将第二条的pick改成squash 保存, 修改提交信息, 再保存，查看git log --oneline, 确认修改完成 使用git push提交（视情况加-fforce） 2. 对单个commits拆分 以合并的结果做拆分演示 想拆分第一条 123git rebase -i Head~1// 或者git rebase -i 33bda27 // 前一条 将第一条的pick改成edit, 后保存并退出 发现此时属于rebase阶段 1git reset HEAD^ // 拉取之后的提交到版本库的文件到暂存区, 改操作不影响工作区 使用git add和git commit分文件进行提交, 生成不同的commits 提交完成后使用git rebase --continue, 完成rebase. 使用git push提交（视情况加-fforce） 3. 更改作者信息上述rebase步骤中加入1git commit --amend --author &quot;aaa &lt;bbb@cc.com&gt;&quot; // 要修改的作者名字和邮箱 4. 如何rebase第一条（root）上述rebase起始步骤中加入1git rebase -i --root// 要修改的作者名字和邮箱 PS：如果想修改root的提交信息呢1234567git checkout &lt;sha1-of-root&gt; // checkout到第一条git commit --amend --author &quot;aaa &lt;bbb@cc.com&gt;&quot; // 要修改的作者名字和邮箱// ORgit commit --amend --reset-authorgit rebase --onto HEAD HEAD master 5. one more thinggit commit加-s参数可以加上Signed-off-by信息","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://www.stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.stanye.com/blog/tags/git/"},{"name":"git rebase","slug":"git-rebase","permalink":"https://www.stanye.com/blog/tags/git-rebase/"}]},{"title":"学习TS的一些知识点总结2","date":"2018-11-23T08:56:26.000Z","path":"2018/11/23/some-basic-knowledge-while-learning-typescript.html","text":"接上一篇，学习TS对JS的一些概念的补充，ES6一些设计的趋向于Java和PHP，有一定的亲和力 类Class 定义事物抽象特点，包含属性和方法 constructor 构造函数, new 的时候自动调用 extends 继承 super 调用父类的构造函数和方法 实例属性ES7支持在 constructor 外也可以定义 对象Object面向对象OOP(Object Oriented Programming)封装Encapsulation继承Inheritance多态Polymorphism存取器(getter &amp; setter)1234567891011121314151617class Mobile &#123; constructor(mobile) &#123; this.mobile = mobile; &#125; get mobile() &#123; return 'iPhone6s'; &#125; set mobile(name) &#123; console.log('setter: ' + name); &#125;&#125;let a = new Mobile('P10'); // setter: P10a.mobile = 'P10 pro'; // setter: P10 proconsole.log(a.mobile); // iPhone6s 想起了之前学vue中双向绑定的原理是什么(靠Object.defineProperty() get set方法) 修饰符(Modifiers) static 修饰静态变量(ES7)和方法(ES6) TS 访问修饰符(Access Modifiers): public 、protected 、 private 抽象类(Abstract Class) 抽象类不允许被实例化 抽象方法必须在子类实现 接口(Interfaces) 描述对象的形象(Sharp) 提取公共实现(implements) 接口可以继承接口 1234567interface Company &#123; alert();&#125;interface System extends Company &#123; isOpenSource();&#125; 接口可以继承类 12345678interface Size &#123; x: number; y: number;&#125;interface System extends Size &#123; os: string&#125; 实现(implements) 公共特性提取成接口（interfaces），用 implements 关键字来实现 一个类可以有多个implements 1class Mobile implements System, Price, Company &#123;&#125;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://www.stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.stanye.com/blog/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://www.stanye.com/blog/tags/typescript/"}]},{"title":"学习TS的一些知识点总结","date":"2018-11-12T06:14:26.000Z","path":"2018/11/12/ts-basics.html","text":"学习TS中, 才发现js基础太差了, 学习整理ing(持续更新…) 数据类型原始数据类型(Primitive data types) Number ES6 可以用二进制表示法前缀0b（或0B）例如0b1010 ES6 可以用八进制表示法0o（或0O）例如0o744 用Number方法转十进制 String Boolean boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数 Null Undefined 与 void 的区别是，undefined 和 null 是所有类型的子类型。 Symbol (ES6新增) MDN文档 空值(Void) TS中才有 TS中用void表示没有任何返回值的函数 123function test(): void &#123; console.log('no return');&#125; 对象类型(Object types)函数声明(函数声明和函数表达式)Function Declaration123456789function test(a: string, b: string): string &#123; return `$&#123;a&#125; is $&#123;b&#125;`&#125;// 上面用解构的写法如下:function test(&#123; a = 'default', b &#125;: &#123; a: string; b: string; &#125;): string &#123; return `$&#123;a&#125; is $&#123;b&#125;`&#125; Function Expression123var test: (a: string, b: string) =&gt; string = function (a: string, b: string): string &#123; return `$&#123;a&#125; is $&#123;b&#125;`&#125; ES6箭头函数和TS的箭头函数会混淆 接口的方式声明12345678interface StringConcatFunc &#123; (a: string, b: string): string&#125;let test: StringConcatFunc; test = function (a: string, b: string): string &#123; return `$&#123;a&#125; is $&#123;b&#125;`; &#125; 可选参数必须放在必选参数后面 a: string, b?: string 或者设置默认值和ES6类似 b?: string = &#39;default&#39;, a: string 此时会报错Parameter cannot have question mark and initializer. 需要修改成b: string = &#39;default&#39;, a: string 支持重载，先精确定义方法，再在最后写实现 导入/导出export 整体导出 1module.exports = aaa; 单个导出 1exports.aaa = aaa; import 整体导入 1import * as aaa from 'aaa'; 官方推荐1234// importimport aaa = require('aaa');// exportexport = aaa; 任意值(Any) 允许赋值为任意类型 未指定其类型会被识别为任意值类型 类型推论(Type Inference)联合类型（Union Types)1let a: number | string; 只能访问所有类型里共有的属性或方法 Interfaces接口, 对行为的抽象, 用classes定义implements(实现) 对类的行为进行抽象 对对象的形状进行描述 123456789interface Mobile &#123; name: string, system: string&#125;let myPhone: Mobile = &#123; name: 'iphone6s', system: 'iOS11.2'&#125; 有点像写react的propType, 变量的形状和接口的形状一定要一致 可选属性 12345678interface Mobile &#123; name: string, system?: string&#125;let myPhone: Mobile = &#123; name: 'iphone6s'&#125; 不报错 任意属性 12345678910interface Mobile &#123; name: string, system?: string, [propName: string]: any&#125;let myPhone: Mobile = &#123; name: 'iphone6s', price: 5388&#125; 只读readonly 12345678910111213interface Mobile &#123; readonly company: string, name: string, system?: string, [propName: string]: any&#125;let myPhone: Mobile = &#123; name: 'iphone6s', price: 5388, company: 'apple'&#125;myPhone.company = 'nokia'; // error 数组类型 type + 方括号 1let arr: string[] = ['1', '2', '3'] 泛型 (Array Generic) 1let arr: Array&lt;string&gt; = ['1', '2', '3'] 接口 12345interface StringArray &#123; [index: number]: string&#125;let arr: StringArray = ['1', '2', '3']; any[] 表示任意数组 类数组 Array-like Object 123function test() &#123; let args: IArguments = arguments;&#125; IArguments就是内置数组 元组Tuple(吐槽记成了元祖, 元祖高达) 与数组类似, 数组内有相同元素, 元组有不同类型 1let test: [string, number] = ['1', 2]; 类型断言Type Assertion &lt;类型&gt;值 123function test (a: string | number) &#123; console.log((&lt;string&gt;a).length);&#125; 值 as 类型 react必须用值 as 类型 泛型Generics 定义函数、接口、类的时候不指定类型，使用的时候再指定 123456789101112function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;function test&lt;T, U&gt;(a: [T, U]): [U, T] &#123; return [a[1], a[0]];&#125;​ `&lt;T&gt;`任意类型 泛型约束 12345678interface LengthWise &#123; length: number&#125;function countArray&lt;T extends LengthWise&gt;(args: T): T &#123; console.log('argsLength: ', args.length); return args;&#125; 泛型接口内置对象 ES标准 Boolean Error Date Regexp global object typescript实现 DOM和BOM Document HTMLElement Event NodeList typescript实现 声明声明文件 放一个单独的文件example.d.ts 声明的使用方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 声明全局变量declare var a: (b: string) =&gt; any;declare const b;declare let c;// 声明全局方法 支持重载declare function test (): any &#123;&#125;// 声明全局类declare class Mobile &#123; name: string; constructor(name: string);&#125;let myPhone = new Mobile('iPhone6s');// 声明全局枚举declare enum Systems &#123; iOS, Android, WindowsPhone, Symbian&#125;console.log(Systems[\"iOS\"] === 0); // trueconsole.log(Systems[0] === \"iOS\"); // true// 声明全局对象 被ES6淘汰declare namespace Example &#123; function test...&#125;// 声明全局类型interface test &#123;&#125;// 声明全局类型type System = string;type SystemVersion = () =&gt; string; // `类型别名`常用于联合类型 type SystemOrVersion = System | SystemVersion; function getSystem(n: SystemOrVersion): System &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125; &#125; // 声明`字符串字面量`类型 type EventNames = 'click' | 'touch' | 'scroll'; function handleEvent(ele: Element, event: EventNames) &#123; // do something &#125;// 扩展全局变量declare global &#123; interface String &#123; sayYes(): string &#125;&#125;// 扩展模块 先import再declareimport * as aaa from 'aaa';declare module 'aaa' &#123; export function lalala(): aaa.toArray();&#125; 第三方声明文件, 发布到@types 用@types下载 http://microsoft.github.io/TypeSearch/ 1npm i @types/react --save package.json中types字段或者index.d.ts 创建types目录, tsconfig.json 中的 paths 和 baseUrl 字段。 12345678910&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"baseUrl\": \"./\", \"paths\": &#123; \"*\": [\"types/*\"] &#125; &#125;&#125;` 声明合并 函数合并(重载) 接口合并 overload 重载(方法名一样，参数不一样) js不支持重载 可以自己根据参数进行条件判断进行重载 闭包实现重载 参考https://www.cnblogs.com/yugege/p/5539020.html ES6带来了Proxy和Reflect可以实现重载 overwrite 重写override 覆盖参考文档 https://www.tslang.cn/docs/home.html https://ts.xcatliu.com","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://www.stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.stanye.com/blog/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://www.stanye.com/blog/tags/typescript/"}]},{"title":"升级macOS Mojave后问题汇总及解决办法","date":"2018-10-23T06:11:26.000Z","path":"2018/10/23/macOS-Mojave-problems-and-solutions.html","text":"搜狗问题描述：系统升级之后发现断断续续一直鼠标在转圈 解决方案：搜狗升级到`4.8`之后解决问题 zsh问题描述：升级后使用iTerm出现乱码，原生terminal没问题 解决方案：iTerms2 -&gt; Preferences -&gt; Advanced -&gt; 搜索LC_CTYPE -&gt; value值设置`zh_CN.UTF-8` VSCode问题描述：字体变细 解决方案：命令行输入`defaults write -g CGFontRenderingFontSmoothingDisabled -bool NO` Wechat和Tim问题描述：输入框焦点容易丢失，必须手动点击程序 解决方案：升级最新版Wechat和Tim Git丢失问题描述：更新后git没了 解决方案：命令行输入`xcode-select –install` Hexo问题描述：写这篇文字的时候，居然发现生成的页面英文的地方被转成日文 解决方案：_config.yml文件language设置`zh-Hans`","categories":[{"name":"IT技巧","slug":"IT技巧","permalink":"https://www.stanye.com/blog/categories/IT技巧/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://www.stanye.com/blog/tags/MacOS/"},{"name":"Mojave","slug":"Mojave","permalink":"https://www.stanye.com/blog/tags/Mojave/"}]},{"title":"leetcode - 350. 两个数组的交集 II","date":"2018-06-06T03:41:43.000Z","path":"2018/06/06/leetcode-350-两个数组的交集-II.html","text":"给定两个数组，写一个方法来计算它们的交集。例如: 给定 nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2]. 注意： - 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 - 我们可以不考虑输出结果的顺序。 跟进: - 如果给定的数组已经排好序呢？你将如何优化你的算法？ - 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ - 如果nums2的元素存储在磁盘上，内存是有限的，你不能一次加载所有的元素到内存中，你该怎么办？ 我的答案： 12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; var arr = []; var List = []; for (var i = 0; i &lt; nums1.length; i++) &#123; List.push(nums1[i]); &#125; for (var i = 0; i &lt; nums2.length; i++) &#123; var cNum = nums2[i]; var cIndex = List.indexOf(cNum); if (cIndex != -1) &#123; delete List[cIndex]; arr.push(cNum); &#125; &#125; return arr;&#125;; 给出的耗时最短解 1234567891011121314151617181920/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; const map=&#123;&#125;; const res=[]; nums1.forEach(function (v) &#123; map[v]?map[v]++:map[v]=1; &#125;); nums2.forEach(function (v) &#123; if(map[v])&#123; res.push(v); map[v]--; &#125; &#125;); return res;&#125;;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://www.stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.stanye.com/blog/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.stanye.com/blog/tags/algorithm/"}]},{"title":"Skeleton Screen - 骨架屏设计","date":"2018-05-30T03:00:00.000Z","path":"2018/05/30/skeleton-screen.html","text":"Skeleton Screen 陈纬杰 - 使用 Skeleton Screen 提升用户感知体验 https://cloud.tencent.com/developer/article/1006169 龙爪槐守望者 - 这个控件叫：Skeleton Screen/加载占位图 https://www.jianshu.com/p/d152e1d84296","categories":[{"name":"产品设计","slug":"产品设计","permalink":"https://www.stanye.com/blog/categories/产品设计/"}],"tags":[{"name":"skeleton screen","slug":"skeleton-screen","permalink":"https://www.stanye.com/blog/tags/skeleton-screen/"}]},{"title":"技术型产品经理需要了解的知识点","date":"2018-05-10T11:11:22.000Z","path":"2018/05/10/Technical-product-manager.html","text":"MVCMVC是一个框架模式，它强制性的使应用程序的输入、处理和输出分开。以JAVA为例，最典型的MVC就是JSP + SERVLET+ JAVABEAN的模式。通俗的讲，程序可以有一种方式的写法，都在JSP的代码中处理所有事情。但是这样回答来极大的耦合问题，所以才去MVC模式把视觉（前台）、后台、数据库拆分开来处理。减少偶尔、增加复用性等。 URL 路由 模板 一段代码经常被重复使用，我们的工程师们会把它封装成一个文件，然后在需要使用的时候去调用它。我们在设计产品的时候其实常用到这个思维，比如设计权限模块，你需要做的是把一个系统中的公司、分公司、部门等进行拆分，封装成不同的功能。 RESTful API http://www.ruanyifeng.com/blog/2014/05/restful_api MySQL Bootstrap Redis, 用Memcached或Redis来做缓存，提高应用性能 版本管理Git、svn Markdown 前后端分离 微信H5开发 Docker 机器学习 Chrome 调试你能够感知到的一般都是你所能看到的，这些BUG都是很简单就能修复的。 CURL 测试 API 数据分析埋点 学前端不要写脚本抢月饼，学后端记得做好权限检查 http的基本原理 app和h5的区别以及通信。 web前端的基本概念。 后台的基本知识 常用的技术术语，比如SDK，插件，接口，协议等等 数据库的基础知识一方面，有助于与技术的沟通及产品的实现；另一方面，特别是在创业型公司，查询后台不完善甚至压根没有，很多时候需要出数据（如了解交易量、转化率等），如果自己不会的话就得麻烦开发大哥了。但是，都很忙的。一次两次还好，次数多了早晚要被嫌弃。有人说提需求开发数据平台，在人力紧张需求优先级低的情况下谁给你开发？select…from…where…group by….order by.. 前端和后端的关系 HTTP与HTTPs的区别 比如get和post 比如算法到底是个啥意思 比如接口是个啥意思（天天说对接，对接什么玩意） XML和Json都是什么 html5里有什么值得利用的新特性 他们按f12调出来的是什么、可以干什么研发资源非常珍贵。 base64编码能帮你们做到什么 数据库的一些基本概念 域名、URL、IP到底都是什么。 主要是网站产品主要依靠浏览器编程语言开发的php,java或者Python。产品项目中使用开发框架，是团队自己研发的框架，还是使用市面上比较流行的框架。其次是数据库的选择，根据你们的业务需求是使用mysql这种关系型数据库还是mongodb这类非关系型数据库最后就是服务器，服务器一般关心的问题就是稳定性，安全性，还有负载了根据不同需求选择服务器，使用什么样的服务器？自己管理的，还是云。云的话还要了解一些云服务和产品的内容，比如RDS，负载均衡，内容分发。手机APP这样的产品需求跨平台性以及其他细节问题。 技术特性技术的生命周期：技术生命周期一般就2~3年，服务器操作系统生命周期会更长一些，，关键问题是这个问题本身就不太现实，我们很难预测2~3年以后我们的产品的样子。作为PM你不用了解具体的实现方式，开发效率和健壮性怎么样，是不是符合我现阶段产品开发的需求。 不管怎么说作为PM掌控产品全局你要知道整个项目的技术开发成本是怎样的。程序员是个喜欢创造的工种，如果你只是设计好了让他们照着设计做他们会玩的很没乐趣的。要让他们也参与其中你会发现你的项目会比你想象中的进展要好。 会写代码是加分项；不了解大局上来就聊代码，是越俎代庖,你需要知道水可以用来泡茶，做汤。不需要知道水是H2O,水有哪些种类，什么水泡茶最好，什么水做汤更赞。忌不懂技术,忌懂技术. https://www.codecademy.com/zh/ 对技术架构或某些技术问题的看法，立刻遭到赞扬：“你很懂技术嘛！”这时马上打着哈哈说：“懂个p啊，我连hello world都不会写，完全是纸上谈兵。”于是嬉笑声中，一群人把手里的箭收起来了。 产品经理懂技术 ＝ 流氓会武术。 你怎么实现我不管，我就要这个这个功能不就是xxx么，你直接说要多久把这次的需求很简单，只要做xxx就行了，prd你看下哈你的产品架构，其实也是技术架构！一定不能乱前端要做哪些？字段、样式、交互（操作前、操作中、操作后）、边界条件（字数、图片尺寸等等对前端说：我们这边新增了哪几个页面，ui设计稿什么样的，交互是什么样的…前端done!对后段说：我们这次的产品大逻辑什么，新增了哪些字段，最重要和复杂的逻辑是哪些，可能要哪边的接口，那边的技术已经帮你找好了….后端done!对qa说：这次的迭代和之前有什么不同，最重要的测试点是什么，有哪些风险要测下，回头上线的时候跟我说下我们一起看下…qa done! http://www.cnblogs.com/dunnice/articles/2733430.html 前端=html+css+js=&gt;结构+字段+样式+交互程序=算法+数据结构https://www.zhihu.com/question/26743347https://www.zhihu.com/question/21380252数据驱动产品的发展～ 不同系统的兼容性问题不同版本的兼容性问题 不同屏幕尺寸的兼容性问题 android 和 ios 系统的规范 android 和 ios 打包发布流程 ‘技术无法实现’的潜台词可能是给的资源不够， 完成不了你的优先级低， 不想给你做看你不爽， 不想给你做这功能太傻不应该做最后才是真的技术无法实现 HTML5和NATIVE的特点和区别，哪些在微信中能做，哪些不能做 如果你知道如果将用户的操作分成0.01秒为单位的节点，并将所有的用户行为都预测出来。你就是产品经理。 在一个项目里面 产品经理看懂一个api 难道不是只要看api说明就行了 为什么要懂技术你知道了 都能做什么 然后不就是你排列组合的天下了如果你看的api没说明 让程序员补去","categories":[{"name":"产品设计","slug":"产品设计","permalink":"https://www.stanye.com/blog/categories/产品设计/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://www.stanye.com/blog/tags/PM/"}]},{"title":"产品经理沟通技巧(pdf)","date":"2018-05-10T11:07:10.000Z","path":"2018/05/10/communicate-with-product-manager-pdf.html","text":"之前做了《产品经理与程序员和谐相处之道》的ppt分享，此处是导出pdf格式. 百度网盘提取地址 提取码: m5mg","categories":[{"name":"产品设计","slug":"产品设计","permalink":"https://www.stanye.com/blog/categories/产品设计/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://www.stanye.com/blog/tags/PM/"},{"name":"ppt","slug":"ppt","permalink":"https://www.stanye.com/blog/tags/ppt/"}]},{"title":"产品经理如何与技术沟通","date":"2018-05-10T11:07:10.000Z","path":"2018/05/10/communicate-with-product-manager.html","text":"产品经理应该：提出来 讲明白 说服他 验收好 核心的竞争优势就是在技术方面，这个是非技术出身的产品经理最缺的一项技能。技术出身的产品经理跟工程师沟通会比较顺畅，能够深刻体会并理解工程师的思维，提出的设计和需求也会比较接地气，因此不容易跟开发人员产生矛盾。需求策划方面，每一个需求功能点的提出，技术出身的产品经理都可以很快评估出技术实现的可行性，实现所需的大概时间，技术存在的一些风险或问题，因此可以很快将需求点落到实处，大大缩短需求到实现转化所需的周期。 工程师的思维跟产品经理的思维，关注点和考虑问题的方式存在很大的区别。会太注重并纠结技术层面的问题，而忽视了产品经理应该关注的是整个产品项目的大局。产品前期的设计才是整个项目的重心，后面的运营推广是项目成败的关键。市场及商业嗅觉不敏感，产品设计，运营推广等领域缺乏相关的经验，这方面需要投入大量的时间去培养与磨炼，比如商业嗅觉的培养，数据运维的数据分析，营销推广的策划和布局，这些都不是一朝一夕可以练好的内功，需要基于大量的阅读学习，观察及实操后一步步磨炼出来。 在产品大方向的把握，设计细节的考量，运营推广思路上面会存在非常多的盲区，导致对整个项目的理解不够透彻 产品经理在项目推进过程中需要面对老板，工程师，设计师，测试人员，运营，市场等各个领域的人，应该学会换位思考，站在各个不同角色的人的立场去考虑问题，才能协调到更多的资源去配合你完成项目的推进工作。 不要花太多的时间去纠结或花在研究技术上面，而应该把自己的时间合理地分配到其他的技能的学习上面。产品经理是一个对综合能力要求特别高的职位，需要不断地学习，不断地吸收这个领域的知道养分。不要因为“技术”这棵小树，而放弃了产品的这座大森林。 做技术时，你经常需要面对的问题是如何解决技术难题；而做了产品，你所面对的大多数问题是如何搞定人。比如，老板提了一个不合理的需求，你应该怎么婉转地打掉；UI设计师跟你闹矛盾，你怎么让她继续配合你工作；项目资源紧缺，开发周期赶不及，你如何才能申请到更多的资源。除了知识面需要扩充好几倍外，做人做事的能力，也要迅速跟上。 找准自己的定位，分析自己之于团队的价值。沟通是一门艺术。艺术源自生活，不必刻意追求。先试着让身边的人快乐。 程序考虑问题的出发点大多是：体现自己的技术水平。 我接触的程序员喜欢用高效、简单、先进的技术手段解决问题。通常他们反驳产品都是想令代码更简单更高效，而产品却变得复杂、多步骤甚至多余。产品都希望把简单留给用户，把复杂留给开发。这是个对立面。所以程序员转产品，首先要改变自己的思维，从用户和需求出发，而不是从技术角度. 产品工作是感性的，做出一款产品与做出一款好产品的差别无比巨大，大部分所谓的产品经理只能说在从事着一份工作而已，得到个好听又最容易被人吐槽的名头，不代表他真的很厉害. 马化腾(Pony)，张小龙，周鸿祎都是程序员出身的、中国最优秀的互联网产品经理。只有当你跨越了傻瓜心态之后，才算是迈出了成功转型产品经理的第一步。 你永远不要假设用户是聪明的，用户的弱智程度永远超出你想象力的下限。所以，当你设计产品的界面和交互的时候，一定不要拿自己的经验去想当然，一定要假设是在给一个弱智做产品，尽量简化，让产品非常易用才行。 真正好的产品经理应该是以结果为导向的. 技术人员如果没有追求完美的心，就无法成为一个优秀的技术人员。然而带有「完美主义综合症」的产品经理是可怕的。 在这个产品经理，视觉设计，程序员共同参与的产品生产过程中，程序员是最后的环节，当程序员在代码实现的过程中发现了产品逻辑的错误，或者产品设计的问题，是非常被动的。这个时候程序员再要求产品经理更改设计，修正产品交互逻辑，产品经理通常的反应就是：「程序员又和我讨价还价，产品deadline又要延后了」，跟着双方就开始剑拔弩张的对峙。 产品经理负责搜集和定义产品需求，整理产品逻辑规则，设计产品原型稿和交互，这个阶段并不需要程序员开始写代码，但是从一开始就让程序员，运营，甚至运维工程师都参与进来 程序员从一开始就了解了产品的来龙去脉，对产品需求和产品要达到的目标非常清楚，这样在和产品经理的配合中，就非常容易理解产品经理提出的很多功能要求，沟通起来非常顺畅；程序员从一开始就参与，并且持续参与产品设计的过程，最大的好处在于从一开始就可以纠正可能出现的产品设计逻辑错误，以及评估技术难以实现的产品功能。这样等到真正进入开发阶段，研发周期是非常可控的，基本不会出现延误。一些有良好产品意识的程序员，可以帮助产品经理从一开始就完善产品逻辑，从实现上修正产品可能遇到的问题，让产品开发过程变得更加有保障。很多产品经理犯的一个重大错误就是：直到原型稿交互稿定稿之后，才交给程序员，之前全无沟通，然后逼着程序员立刻评估一个精确的开发周期。这个时候程序员内心是非常抗拒的。一来我完全不了解这个产品，不知道做这个产品是干啥的？能够解决什么问题？是否有更好的替代解决方案；二来我也不清楚这个产品逻辑是否有需要调整和修正的地方，以及有些技术上需要投入很多资源但是不划算的功能。 产品经理应该传递一个信息：产品是大家的，需要大家共同合作，一起努力把产品做好，无论是产品，视觉，研发，还是运营，大家都是为了一个共同的目标而努力。 不需要懂技术，但是逻辑要严谨 Bug修好了程序就会马上运营，程序员可以接着下一个代码的编写，但是先生生活中可能不太一样，刚吵完一架，可能就没法友好的合作了。 如果老板同意说，如果PM加需求，要么就砍掉一个差不多规模的旧的，要么就延长期限，我觉得肯定不会打起来。 戒掉“应该”，“大概”，“也许”，”我想“，”可能“这种模棱两可的词语。 to be continue","categories":[{"name":"产品设计","slug":"产品设计","permalink":"https://www.stanye.com/blog/categories/产品设计/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://www.stanye.com/blog/tags/PM/"}]},{"title":"high-concurrency-experience","date":"2018-04-30T06:41:42.000Z","path":"2018/04/30/high-concurrency-experience.html","text":"用户数增长，公司项目遇到并发的难题。网上学习几点如下： 处理高并发的业务逻辑 前端: 异步请求 + 资源静态化 + cdn 后端: 请求队列 + 轮询分发 + 负载均衡 + 共享缓存 数据层: redis + 数据分表 + 写队列 存储: raid阵列 + 热备 网络: dns轮询 + DDOS防护 简而言之就是分区、分表、分库，后端算法优化，公共数据缓存，服务器上负载均衡，前端减少连接数、瘦身 如何学习高并发redis, nginx, keeplive, DRBD, heartbeat这些工具在虚拟机上面跑起来.因为有些工具运行的配置要求太高, 必须多台服务器配合才能完成. 总监那边选型TiDB，已经和老板申报了机器. 模拟高并发tengine 公司内则用php写了一些针对要测试的功能点的脚本 如何向别人吹我们的系统 采用了复杂的分层方案，以保证良好的性能和水平扩展性。要点如下: 动静分离: 通过CDN系统分发静态资源: js, css, 图片, 音频, 视频等资源 应用集群: 通过负载均衡技术，实现的应用服务器集群，具有很高的并发处理能力和扩展性。可以根据实际需要迅速扩充服务器，部署应用之后即可直接上线提供服务。 缓存集群: 通过一致性Hash算法实现实现缓存分片，保证缓存系统的响应速度和可扩展性。通过主从复制，保证缓存系统的可靠性。 读写分离: 读写分离，保证两者都具有具有良好的性能。采用写直达技术，保证缓存和数据库数据的一致性。 数据库集群: 采用分布式数据库集群技术（垂直和水平切分技术，复制技术），保证数据库系统的性能、稳定性和可扩展性。 消息队列和辅助任务集群: 长时间运行的任务，先入队列，再由系统调度到后台任务集群中运行，可保证前端页面的响应性能，并为大型的分析作业提供运行环境，并具有很高的扩展能力。 充分测试: 持续集成: 持续的自动化测试。 压力测试: 系统功能模块在上线之前，会经过充分的性能和压力测试，只有在功能、性能和吞吐量达到预期设计指标后，才会上线运行。 部署和监控方案: 红蓝部署: 保证系统升级和发布的稳定性，出现问题时，可迅速回退。 容灾机制: 自动备份机制，降低灾难性事件（如自然灾害等）对系统的影响。 监控方案: 完善的自动监控和报警方案，可以提前发现和报告异常情况，并提醒运维团队及时处理相关问题。","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://www.stanye.com/blog/tags/redis/"},{"name":"nginx","slug":"nginx","permalink":"https://www.stanye.com/blog/tags/nginx/"}]},{"title":"rm-input-type-number-arrows","date":"2017-06-05T07:18:18.000Z","path":"2017/06/05/rm-input-type-number-arrows.html","text":"移除input type=number的箭头 css1234567891011// chromeinput::-webkit-outer-spin-button,input::-webkit-inner-spin-button &#123; -webkit-appearance: none !important; margin: 0;&#125;// firefoxinput[type=\"number\"] &#123; -moz-appearance:textfield;&#125; 不用type=number将type=&quot;number&quot;改为type=&quot;tel&quot;, 同样是数字键盘，但是没有箭头。","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://www.stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.stanye.com/blog/tags/css/"}]},{"title":"Vue更新数组状态方法","date":"2017-05-16T06:58:53.000Z","path":"2017/05/16/vue-update-array.html","text":"直接修改数组检测不到变化：12vm.Arr[index] = newItem;vm.Arr.length = newLength; 由于JavaScript的限制，采用以下方法: 1234// way 1Vue.set(old.Arr, index, newItem);// way 2old.Arr.splice(index, 1, newItem);","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://www.stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.stanye.com/blog/tags/vue/"},{"name":"array","slug":"array","permalink":"https://www.stanye.com/blog/tags/array/"}]},{"title":"mysql查重","date":"2017-05-03T06:30:20.000Z","path":"2017/05/03/mysql-duplicate-checking.html","text":"mysql查重： 单字段1select * from member where mobile in (select mobile from member group by mobile having count(mobile) &gt; 1) 单字段查重删除1delete from member where mobile in (select mobile from member group by mobile having count(mobile) &gt; 1) and rowid not in (select min(rowid) from member group by mobile having count(mobile)&gt;1) 多字段1select * from member a where (a.mobile,a.email) in (select mobile,email from member group by mobile,email having count(*) &gt; 1) 多字段查重删除1delete from member a where (a.mobile,a.email) in (select mobile,email from member group by mobile,email having count(*) &gt; 1) and rowid not in (select min(rowid) from member group by mobile,email having count(*)&gt;1)","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.stanye.com/blog/tags/mysql/"}]},{"title":"php&引用","date":"2017-04-29T11:10:39.000Z","path":"2017/04/29/php-cite.html","text":"php的引用–在变量或者函数、对象等前面加上&amp;符号,允许两个变量来指向同一个内容123456$a = \"111\";$b = &amp;$a;echo $a; // 这里输出:111echo $b; // 这里输出:111$b=\"222\";echo $a; // 这里$a的值变为222 所以输出222 echo $b;//这里输出222 ￼ 1234567function demo(&amp;$a)&#123; $a = $a + 1;&#125;$b = 100;echo $b; // 100demo($b); //$b的内存地址echo $b; // 101 123456function &amp;test()&#123; static $b=0;//申明一个静态变量 $b=$b+1; echo $b; return $b;&#125;","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.stanye.com/blog/tags/php/"}]},{"title":"使用using关键字对连接进行简化","date":"2017-04-29T06:39:10.000Z","path":"2017/04/29/sql-using.html","text":"USING进行简化： 1、查询必须是等连接的 2、等连接中的列必须是同名123select aname, bname from a inner join b using(category) 在使用using是需要注意以下几个问题 1、在select子句中只能指定该列名，不能使用表名或别名 2、在using子句中也只能单独使用列名对于多与两个表的连接12345select c.c_name, p.p_name , f.f_namefrom ctable c, ptable p, ftable fwhere c.user_id = f.user_idand p.p_id = f.p_id and p.type_id = f.type_id; 使用using对上面的sql语句进行重写 1234567select c.c_name, p.p_name, f.type from ctable c inner join ftable f using(user_id) inner join ptable p using(p_id) inner join ftable f using(type_id);","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.stanye.com/blog/tags/mysql/"},{"name":"using","slug":"using","permalink":"https://www.stanye.com/blog/tags/using/"}]},{"title":"mysql-simple-usage","date":"2017-04-28T06:16:57.000Z","path":"2017/04/28/mysql-simple-usage.html","text":"连接mysql 1mysql -h&#123;server host address&#125; -u&#123;username&#125; －p&#123;password&#125; 修改密码 1mysqladmin -u&#123;username&#125; -p&#123;oldpassword&#125; password&#123;newpassword&#125; 增加新用户 已经进入mysql 1grant select on &#123;dbname&#125;.* to &#123;username&#125;@&#123;host&#125; identified by &quot;&#123;password&#125;&quot; 但是为了防止host远程可以连接，一般只开放host配置到localhost，即先登录到服务器，再连接本机mysql 常用命令 1234567891011121314151617181920212223242526272829303132// 显示数据库show databases;// 显示表use &#123;某个database&#125;;show tables;// 显示某个表结构desc &#123;表名&#125;;// 建库create database &#123;dbname&#125;;// 建表create table &#123;tablename&#125; (&#123;`id`....,`name`...&#125;);// 删库drop database &#123;dbname&#125;;// 删表drop table &#123;tablename&#125;;// 增删改查等不做赘述// 增加字段alter table dbname add column &#123;字段名&#125;// 修改字段alter table dbname change &#123;字段名&#125; &#123;新字段名&#125;// 删除字段alter table dbname drop column &#123;字段名&#125; 导出数据 1mysqldump &#123;dbname&#125; &gt; jiaoben.mysql","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.stanye.com/blog/tags/mysql/"}]},{"title":"mysql给表赋权","date":"2017-04-04T03:22:52.000Z","path":"2017/04/04/mysql-grant.html","text":"mysql赋权：1grant drop on sch_m.common_member to dev@'localhost'","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.stanye.com/blog/tags/mysql/"}]},{"title":"css两行截取","date":"2017-04-03T08:30:22.000Z","path":"2017/04/03/css-cut-2-line.html","text":"css两行截取解决办法： 12345overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://www.stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.stanye.com/blog/tags/css/"}]},{"title":"table文字溢出控制","date":"2017-04-03T04:30:22.000Z","path":"2017/04/03/css-fix-table-wrap.html","text":"table换行解决办法： 1234567891011table &#123; width:100px; table-layout:fixed;&#125;td &#123; width:100%; word-break:keep-all; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;&#125;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://www.stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.stanye.com/blog/tags/css/"},{"name":"table","slug":"table","permalink":"https://www.stanye.com/blog/tags/table/"}]},{"title":"php file_put_contents 函数","date":"2017-03-28T01:21:11.000Z","path":"2017/03/28/php-file_put_contents.html","text":"file_put_contents()功能函数（集成了fopen、fwrite、fclose) 将一个字符串写入文件.1int file_put_contents ( string filename, string data [, int flags [, resource context]] ) 和依次调用 fopen()，fwrite() 以及 fclose() 功能一样。参数 data 可以是数组，这就相当于 file_put_contents($filename, join(‘’, $array)) filename 要被写入数据的文件名。 data 要写入的数据。类型可以是 string，array 或者是 stream 资源（如上面所说的那样）。 flags 可以是 FILE_USE_INCLUDE_PATH，FILE_APPEND 和／或 LOCK_EX（获得一个独占锁定），然而使用 FILE_USE_INCLUDE_PATH 时要特别谨慎。 context 一个 context 资源。","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.stanye.com/blog/tags/php/"}]},{"title":"sql note","date":"2017-03-27T10:30:22.000Z","path":"2017/03/27/sql-join.html","text":"left-join/right join/inner join left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录.right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录. inner join(等值联接) 只返回两个表中联结字段相等的行. left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录.B表记录不足的地方均为NULL.LEFT JOIN操作用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，即使在第二个（右边）表中并没有相符值的记录 right join和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充. inner join并不以谁为基础,它只显示符合条件的记录 limit 取出第一条记录。 1select * from tablename limit 0,1 第二条记录 1select * from tablename limit 1,1 从第11条到31条（共计20条） 1select * from tablename limit 10,20","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.stanye.com/blog/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://www.stanye.com/blog/tags/sql/"}]},{"title":"php抽象类","date":"2017-03-27T06:56:20.000Z","path":"2017/03/27/php-abstract-class.html","text":"php抽象类: PHP5支持抽象类和抽象方法。 抽象类不能被实例化，必须先继承再实例化。 继承抽象类, 子类必须全部实现抽象类中的方法, 而且public、private、protected只能高不能低 12345678910111213141516171819202122232425262728293031323334353637383940abstract class AbstractClass&#123; // 强制要求子类定义这些方法 abstract protected function getValue(); abstract protected function prefixValue($prefix); // 普通方法（非抽象方法） public function printOut() &#123; print $this-&gt;getValue; &#125;&#125;class ConcreteClass1 extends AbstractClass&#123; protected function getValue() &#123; return \"ConcreteClass1\"; &#125; public function prefixValue($prefix) &#123; return \"&#123;$prefix&#125;ConcreteClass1\"; &#125;&#125;class ConcreteClass2 extends AbstractClass&#123; public function getValue() &#123; return \"ConcreteClass2\"; &#125; public function prefixValue($prefix) &#123; return \"&#123;$prefix&#125;ConcreteClass1\"; &#125;&#125;$class1 = new ConcreteClass1;$class1-&gt;printOut();echo $class1-&gt;prefixValue('FOO_') .\"\\n\";$class2 = new ConcreteClass2;$class2-&gt;printOut();echo $class2-&gt;prefixValue('FOO_') .\"\\n\"; 以上例程会输出： ConcreteClass1 FOO_ConcreteClass1 ConcreteClass2 FOO_ConcreteClass2 抽象类的子类中的普通方法执行方式和其他类相同","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.stanye.com/blog/tags/php/"},{"name":"abstract class","slug":"abstract-class","permalink":"https://www.stanye.com/blog/tags/abstract-class/"}]},{"title":"jQuery判断页面滚动到底/到顶","date":"2016-09-30T07:12:19.000Z","path":"2016/09/30/jquery-scrollTop.html","text":"概念12345678// 垂直滚动条$(document).scrollTop()// 水平滚动条$(document).scrollLeft()// 页面高度$(document).height()// 浏览器窗口高度$(window).height() 实现1234// 到顶$(document).scrollTop() == 0// 到底$(document).scrollTop() &gt;= $(document).height() - $(window).height()","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://www.stanye.com/blog/categories/FrontEnd/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.stanye.com/blog/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://www.stanye.com/blog/tags/jquery/"}]},{"title":"regex in my program","date":"2016-07-15T03:41:43.000Z","path":"2016/07/15/regex-used.html","text":"用到的一些正则记录： 匹配&gt;&lt; &gt;[\\s]+&lt; 匹配反斜杠(匹配一个反斜杠要用四个反斜杠) 1\\\\\\\\ 字符串里面表示斜杠就需要两个斜杠\\\\ 正则表达式里的斜杠需要转意，是用\\\\标示。 第一个斜杠是转义符，第二个斜杠是斜杠本身，第三个斜杠是转义符，第四个斜杠是斜杠本身 密码校验 1public static final String PASSWORD_PATTERN = \"^(?![a-zA-z]+$)(?!\\\\d+$)(?![!\\\"#$%&amp;#$%&amp;amp;'()*+,-./:;&amp;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@\\\\[\\\\]^_`&#123;|&#125;~]+$)[a-zA-Z\\\\d!\\\"#$%&amp;#$%&amp;amp;'()*+,-./:;&amp;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@\\\\[\\\\]^_`&#123;|&#125;~]&#123;6,16&#125;$\"; input标签验证 123456789101112131415161718// 只能输入英文&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^a-zA-Z]/g,'')\" /&gt;// 无法粘贴&lt;input type=\"text\" onkeydown=\"fncKeyStop(event)\" onpaste=\"return false\" /&gt;// 屏蔽右键&lt;input type=\"text\" oncontextmenu=\"return false\" /&gt;// 只能输入数字&lt;input type=\"text\" onkeyup=\"this.value=this.value.replace(/\\D/g,'')\" /&gt;// 只能输入数字，小数点：&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\d\\.]/g,'')\"&gt; /&gt;// 只能输入数字，小数点，下划线：&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\d\\._]/g,'')\" /&gt;// 只能输入汉字：&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\u4E00-\\u9FA5]/g,'')\" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\u4E00-\\u9FA5]/g,''))\"&gt;// 禁止输入法输入：&lt;input type=\"text\" style=\"ime-mode: disabled\"&gt;","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://www.stanye.com/blog/categories/BackEnd/"}],"tags":[{"name":"regex","slug":"regex","permalink":"https://www.stanye.com/blog/tags/regex/"}]}]